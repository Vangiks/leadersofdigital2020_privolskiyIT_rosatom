////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ СО СТРОКАМИ

// Функция "расщепляет" строку на подстроки, используя заданный
//      разделитель. Разделитель может иметь любую длину.
//      Если в качестве разделителя задан пробел, рядом стоящие пробелы
//      считаются одним разделителем, а ведущие и хвостовые пробелы параметра Стр
//      игнорируются.
//      Например,
//      РазложитьСтрокуВМассивПодстрок(",один,,,два", ",") возвратит массив значений из пяти элементов,
//      три из которых - пустые строки, а
//      РазложитьСтрокуВМассивПодстрок(" один   два", " ") возвратит массив значений из двух элементов
//
//  Параметры:
//      Стр -           строка, которую необходимо разложить на подстроки.
//                      Параметр передается по значению.
//      Разделитель -   строка-разделитель, по умолчанию - запятая.
//
//  Возвращаемое значение:
//      массив значений, элементы которого - подстроки
//
Функция РазложитьСтрокуВМассивПодстрок(Знач Стр, Разделитель = ",") Экспорт
	
	МассивСтрок = Новый Массив();
	Если Разделитель = " " Тогда
		Стр = СокрЛП(Стр);
		Пока 1 = 1 Цикл
			Поз = Найти(Стр, Разделитель);
			Если Поз = 0 Тогда
				МассивСтрок.Добавить(Стр);
				Возврат МассивСтрок;
			КонецЕсли;
			МассивСтрок.Добавить(Лев(Стр, Поз - 1));
			Стр = СокрЛ(Сред(Стр, Поз));
		КонецЦикла;
	Иначе
		ДлинаРазделителя = СтрДлина(Разделитель);
		Пока 1 = 1 Цикл
			Поз = Найти(Стр, Разделитель);
			Если Поз = 0 Тогда
				Если (СокрЛП(Стр) <> "") Тогда
					МассивСтрок.Добавить(Стр);
				КонецЕсли;
				Возврат МассивСтрок;
			КонецЕсли;
			МассивСтрок.Добавить(Лев(Стр,Поз - 1));
			Стр = Сред(Стр, Поз + ДлинаРазделителя);
		КонецЦикла;
	КонецЕсли;
	
КонецФункции 

// Возвращает строку, полученную из массива элементов, разделенных символом разделителя
//
// Параметры:
//  Массив - Массив - массив элементов из которых необходимо получить строку
//  Разделитель - Строка - любой набор символов, который будет использован как разделитель между элементами в строке
//
// Возвращаемое значение:
//  Результат - Строка - строка, полученная из массива элементов, разделенных символом разделителя
// 
Функция ПолучитьСтрокуИзМассиваПодстрок(Массив, Разделитель = ",") Экспорт
	
	// возвращаемое значение функции
	Результат = "";
	
	Для Каждого Элемент ИЗ Массив Цикл
		
		Подстрока = ?(ТипЗнч(Элемент) = Тип("Строка"), Элемент, Строка(Элемент));
		
		РазделительПодстрок = ?(ПустаяСтрока(Результат), "", Разделитель);
		
		Результат = Результат + РазделительПодстрок + Подстрока;
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

// Сравнить две строки версий.
//
// Параметры
//  СтрокаВерсии1  – Строка – номер версии в формате РР.{П|ПП}.ЗЗ.СС
//  СтрокаВерсии2  – Строка – второй сравниваемый номер версии
//
// Возвращаемое значение:
//   Число   – больше 0, если СтрокаВерсии1 > СтрокаВерсии2; 0, если версии равны.
//
Функция СравнитьВерсии(Знач СтрокаВерсии1, Знач СтрокаВерсии2) Экспорт
	
	Строка1 = ?(ПустаяСтрока(СтрокаВерсии1), "0.0.0.0", СтрокаВерсии1);
	Строка2 = ?(ПустаяСтрока(СтрокаВерсии2), "0.0.0.0", СтрокаВерсии2);
	Версия1 = РазложитьСтрокуВМассивПодстрок(Строка1, ".");
	Если Версия1.Количество() <> 4 Тогда
		ВызватьИсключение ПодставитьПараметрыВСтроку(
		                    НСтр("ru = 'Неправильный формат строки версии: %1'"), СтрокаВерсии1);
	КонецЕсли;
	Версия2 = РазложитьСтрокуВМассивПодстрок(Строка2, ".");
	Если Версия2.Количество() <> 4 Тогда
		ВызватьИсключение ПодставитьПараметрыВСтроку(
	                         НСтр("ru = 'Неправильный формат строки версии: %1'"), СтрокаВерсии2);
	КонецЕсли;
	
	Результат = 0;
	Для Разряд = 0 По 3 Цикл
		Результат = Число(Версия1[Разряд]) - Число(Версия2[Разряд]);
		Если Результат <> 0 Тогда
			Возврат Результат;
		КонецЕсли;
	КонецЦикла;
	Возврат Результат;
	
КонецФункции

// Подставляет параметры в строку. Максимально возможное число параметров - 9.
// Параметры в строке задаются как %<номер параметра>. Нумерация параметров
// начинается с единицы.
//
// Параметры
//  СтрокаПодстановки  – Строка – шаблон строки с параметрами (вхождениями вида "%ИмяПараметра").
// Параметр<n>         - Строка - параметр
// Возвращаемое значение:
//   Строка   – текстовая строка с подставленными параметрами
//
// Пример:
// Строка = ПодставитьПараметрыВСтроку(НСтр("ru='%1 пошел в %2'"), "Вася", "Зоопарк");
//
Функция ПодставитьПараметрыВСтроку( Знач СтрокаПодстановки,
									Знач Параметр1,
									Знач Параметр2 = Неопределено,
									Знач Параметр3 = Неопределено,
									Знач Параметр4 = Неопределено,
									Знач Параметр5 = Неопределено,
									Знач Параметр6 = Неопределено,
									Знач Параметр7 = Неопределено,
									Знач Параметр8 = Неопределено,
									Знач Параметр9 = Неопределено) Экспорт
	
	Если СтрокаПодстановки = Неопределено ИЛИ СтрДлина(СтрокаПодстановки) = 0 Тогда
		Возврат "";
	КонецЕсли;
	
	Результат = "";
	НачПозиция = 1;
	Позиция = 1;
	Пока Позиция <= СтрДлина(СтрокаПодстановки) Цикл
		СимволСтроки = Сред(СтрокаПодстановки, Позиция, 1);
		Если СимволСтроки <> "%" Тогда
			Позиция = Позиция + 1;
			Продолжить;
		КонецЕсли;
		Результат = Результат + Сред(СтрокаПодстановки, НачПозиция, Позиция - НачПозиция);
		Позиция = Позиция + 1;
		СимволСтроки = Сред(СтрокаПодстановки, Позиция, 1);
		
		Если СимволСтроки = "%" Тогда
			Позиция = Позиция + 1;
			НачПозиция = Позиция;
			Продолжить;
		КонецЕсли;
		
		Попытка
			НомерПараметра = Число(СимволСтроки);
		Исключение
			ВызватьИсключение НСтр("ru='Входная строка СтрокаПодстановки имеет неверный формат: %'" + СимволСтроки);
		КонецПопытки;
		
		Если СимволСтроки = "1" Тогда
			ЗначениеПараметра = Параметр1;
		ИначеЕсли СимволСтроки = "2" Тогда
			ЗначениеПараметра = Параметр2;
		ИначеЕсли СимволСтроки = "3" Тогда
			ЗначениеПараметра = Параметр3;
		ИначеЕсли СимволСтроки = "4" Тогда
			ЗначениеПараметра = Параметр4;
		ИначеЕсли СимволСтроки = "5" Тогда
			ЗначениеПараметра = Параметр5;
		ИначеЕсли СимволСтроки = "6" Тогда
			ЗначениеПараметра = Параметр6;
		ИначеЕсли СимволСтроки = "7" Тогда
			ЗначениеПараметра = Параметр7;
		ИначеЕсли СимволСтроки = "8" Тогда
			ЗначениеПараметра = Параметр8;
		ИначеЕсли СимволСтроки = "9" Тогда
			ЗначениеПараметра = Параметр9;
		Иначе
			ВызватьИсключение НСтр("ru='Входная строка СтрокаПодстановки имеет неверный формат: %'" + ЗначениеПараметра);
		КонецЕсли;
		Если ЗначениеПараметра = Неопределено Тогда
			ЗначениеПараметра = "";
		Иначе
			ЗначениеПараметра = Строка(ЗначениеПараметра);
		КонецЕсли;
		Результат = Результат + ЗначениеПараметра;
		Позиция = Позиция + 1;
		НачПозиция = Позиция;
	
	КонецЦикла;
	
	Если (НачПозиция <= СтрДлина(СтрокаПодстановки)) Тогда
		Результат = Результат + Сред(СтрокаПодстановки, НачПозиция, СтрДлина(СтрокаПодстановки) - НачПозиция + 1);
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции

// Подставляет параметры в строку. Неограниченное число параметров в строке.
// Параметры в строке задаются как %<номер параметра>. Нумерация параметров
// начинается с единицы.
//
// Параметры
//  СтрокаПодстановки  – Строка – шаблон строки с параметрами (вхождениями вида "%1").
//  МассивПараметров   - Массив - массив строк, которые соответствуют параметрам в строке подстановки
//
// Возвращаемое значение:
//   Строка   – текстовая строка с подставленными параметрами
//
// Пример:
// МассивПараметров = Новый Массив;
// МассивПараметров = МассивПараметров.Добавить("Вася");
// МассивПараметров = МассивПараметров.Добавить("Зоопарк");
//
// Строка = ПодставитьПараметрыВСтроку(НСтр("ru='%1 пошел в %2'"), МассивПараметров);
//
Функция ПодставитьПараметрыВСтрокуИзМассива(Знач СтрокаПодстановки, знач МассивПараметров) Экспорт
	
	СтрокаРезультата = СтрокаПодстановки;
	
	Для Индекс = 1 По МассивПараметров.Количество() Цикл
		Если Не ПустаяСтрока(МассивПараметров[Индекс-1]) Тогда
			СтрокаРезультата = СтрЗаменить(СтрокаРезультата, "%"+Строка(Индекс), МассивПараметров[Индекс-1]);
		КонецЕсли;
	КонецЦикла;
	
	Возврат СтрокаРезультата;
	
КонецФункции

// Проверяет содержит ли строка только цифры.
//
// Параметры:
//  СтрокаПроверки - строка для проверки.
//  УчитыватьЛидирующиеНули - Булево - нужно ли учитывать лидирующие нули.
//  УчитыватьПробелы - Булево - нужно ли учитывать пробелы.
//
// Возвращаемое значение:
//  Истина       - строка содержит только цифры;
//  Ложь         - строка содержит не только цифры.
//
Функция ТолькоЦифрыВСтроке(Знач СтрокаПроверки, Знач УчитыватьЛидирующиеНули = Истина, Знач УчитыватьПробелы = Истина) Экспорт
	
	Если ТипЗнч(СтрокаПроверки) <> Тип("Строка") Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если НЕ ЗначениеЗаполнено(СтрокаПроверки) Тогда
		Возврат Истина;
	КонецЕсли;
	
	Если НЕ УчитыватьПробелы Тогда
		СтрокаПроверки = СтрЗаменить(СтрокаПроверки, " ", "");
	КонецЕсли;
	
	Если НЕ УчитыватьЛидирующиеНули Тогда
		НомерПервойЦифры = 0;
		Для а = 1 По СтрДлина(СтрокаПроверки) Цикл
			НомерПервойЦифры = НомерПервойЦифры + 1;
			КодСимвола = КодСимвола(Сред(СтрокаПроверки, а, 1));
			Если КодСимвола <> 48 Тогда
				Прервать;
			КонецЕсли;
		КонецЦикла;
		СтрокаПроверки = Сред(СтрокаПроверки, НомерПервойЦифры);
	КонецЕсли;
	
	Для а = 1 По СтрДлина(СтрокаПроверки) Цикл
		КодСимвола = КодСимвола(Сред(СтрокаПроверки, а, 1));
		Если НЕ (КодСимвола >= 48 И КодСимвола <= 57) Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Истина;
	
КонецФункции // ТолькоЦифрыВСтроке()

// Удаляет двойные кавычки с начала и конца строки, если они есть.
//
// Параметры:
//  Строка       - входная строка;
//
// Возвращаемое значение:
//  Строка - строка без двойных кавычек.
// 
Функция СократитьДвойныеКавычки(Знач Строка) Экспорт
	
	Результат = Строка;
	Пока Найти(Результат, """") = 1 Цикл
		Результат = Сред(Результат, 2); 
	КонецЦикла; 
	Пока Найти(Результат, """") = СтрДлина(Результат) Цикл
		Результат = Сред(Результат, 1, СтрДлина(Результат) - 1); 
	КонецЦикла; 
	Возврат Результат;
	
КонецФункции 

// Процедура удаляет из строки указанное количество символов справа
//
Процедура УдалитьПоследнийСимволВСтроке(Текст, ЧислоСимволов) Экспорт
	
	Текст = Лев(Текст, СтрДлина(Текст) - ЧислоСимволов);
	
КонецПроцедуры 

// Находит символ в строке с конца
//
Функция НайтиСимволСКонца(Знач СтрокаВся, Знач ОдинСимвол) Экспорт
	
	НачальнаяПозиция = 1; 
	ДлинаСтроки = СтрДлина(СтрокаВся);
	
	Для ТекущаяПозиция = 1 По СтрДлина(СтрокаВся) Цикл
		РеальнаяПозиция = ДлинаСтроки - ТекущаяПозиция + 1;
		ТекущийСимвол = Сред(СтрокаВся, РеальнаяПозиция, 1);
		Если ТекущийСимвол = ОдинСимвол Тогда
			Возврат РеальнаяПозиция;
		КонецЕсли;
	КонецЦикла;
	
	Возврат 0;
	
КонецФункции

// Функция проверяет, является ли переданная в неё строка уникальным идентификатором
//
Функция ЭтоУникальныйИдентификатор(ИдентификаторСтрока) Экспорт
	
	УИСтрока = ИдентификаторСтрока;
	Шаблон = "XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX";
	
	Если СтрДлина(Шаблон) <> СтрДлина(УИСтрока) Тогда
		Возврат Ложь;
	КонецЕсли;
	Для Сч = 1 По СтрДлина(УИСтрока) Цикл
		Если КодСимвола(Шаблон, сч) = 88 И 
			((КодСимвола(УИСтрока, сч) < 48 ИЛИ КодСимвола(УИСтрока, сч) > 57) И (КодСимвола(УИСтрока, сч) < 97 или КодСимвола(УИСтрока, сч) > 102)) Тогда
			Возврат ложь; 
		 ИначеЕсли КодСимвола(Шаблон, сч) = 45 И КодСимвола(УИСтрока, сч) <> 45 Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Истина;

КонецФункции

// Формирует строку повторяющихся символов заданной длины
//
Функция СформироватьСтрокуСимволов(Символ, КоличествоСимволов) Экспорт
	
	// возвращаемое значение функции
	Результат = "";
	
	Для Индекс = 1 ПО КоличествоСимволов Цикл
		
		Результат = Результат + Символ;
		
	КонецЦикла;
	
	Возврат Результат;
КонецФункции

// Дополняет переданную в качестве первого параметра строку символами слева\справа до заданной длины и возвращает ее
// Незначащие символы слева и справа удаляются
// По умолчанию функция добавляет строку нулями слева
//
// Параметры:
//  Строка      - Строка - исходная строка, которую необходимо дополнить символами до заданной длины
//  ДлинаСтроки - Число - требуемая конечная длина строки
//  Символ      - Строка - (необязательный) значение символа, которым необходимо дополнить строку
//  Режим       - Строка - (необязательный) [Слева|Справа] режим добавления символов к исходной строке: слева или справа
// 
// Пример 1:
// Строка = "1234"; ДлинаСтроки = 10; Символ = "0"; Режим = "Слева"
// Возврат: "0000001234"
//
// Пример 2:
// Строка = " 1234  "; ДлинаСтроки = 10; Символ = "#"; Режим = "Справа"
// Возврат: "1234######"
//
// Возвращаемое значение:
//  Строка - строка, дополненная символами слева или справа
//
Функция ДополнитьСтроку(Знач Строка, Знач ДлинаСтроки, Знач Символ = "0", Знач Режим = "Слева") Экспорт
	
	Если ПустаяСтрока(Символ) Тогда
		Символ = "0";
	КонецЕсли;
	
	// длина символа не должна превышать единицы
	Символ = Лев(Символ, 1);
	
	// удаляем крайние пробелы слева и справа строки
	Строка = СокрЛП(Строка);
	
	КоличествоСимволовНадоДобавить = ДлинаСтроки - СтрДлина(Строка);
	
	Если КоличествоСимволовНадоДобавить > 0 Тогда
		
		СтрокаДляДобавления = СформироватьСтрокуСимволов(Символ, КоличествоСимволовНадоДобавить);
		
		Если ВРег(Режим) = "СЛЕВА" Тогда
			
			Строка = СтрокаДляДобавления + Строка;
			
		ИначеЕсли ВРег(Режим) = "СПРАВА" Тогда
			
			Строка = Строка + СтрокаДляДобавления;
			
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат Строка;
	
КонецФункции

// Удаляет повторяющиеся символы слева/справа в переданной строке
//
// Параметры:
//  Строка      - Строка - исходная строка, из которой необходимо удалить повторяющиеся символы
//  Символ      - Строка - значение символа, который необходимо удалить
//  Режим       - Строка - (необязательный) [Слева|Справа] режим добавления символов к исходной строке: слева или справа
//
Функция УдалитьПовторяющиесяСимволы(Знач Строка, Знач Символ, Знач Режим = "Слева") Экспорт
	
	Если ВРег(Режим) = "СЛЕВА" Тогда
		
		Пока Лев(Строка, 1)= Символ Цикл
			
			Строка = Сред(Строка, 2);
			
		КонецЦикла;
		
	ИначеЕсли ВРег(Режим) = "СПРАВА" Тогда
		
		Пока Прав(Строка, 1)= Символ Цикл
			
			Строка = Лев(Строка, СтрДлина(Строка) - 1);
			
		КонецЦикла;
		
	КонецЕсли;
	
	Возврат Строка;
КонецФункции

// Получает номер версии конфигурации без номера сборки
//
// Параметры:
//  Версия - Строка - версия конфигурации в формате РР.ПП.ЗЗ.СС,
//                    где СС – номер сборки, который будет удален
// 
//  Возвращаемое значение:
//  Строка - номер версии конфигурации без номера сборки в формате РР.ПП.ЗЗ
//
Функция ВерсияКонфигурацииБезНомераСборки(Знач Версия) Экспорт
	
	Массив = РазложитьСтрокуВМассивПодстрок(Версия, ".");
	
	Если Массив.Количество() < 3 Тогда
		Возврат Версия;
	КонецЕсли;
	
	Результат = "[Редакция].[Подредакция].[Релиз]";
	Результат = СтрЗаменить(Результат, "[Редакция]",    Массив[0]);
	Результат = СтрЗаменить(Результат, "[Подредакция]", Массив[1]);
	Результат = СтрЗаменить(Результат, "[Релиз]",       Массив[2]);
	
	Возврат Результат;
КонецФункции

// Назначение: Для начальной строки применить маску ввода, 
// данная функция необходима в случае программного заполнения поля, которое вводится по маске
// так как 1С хранит информацию вместе с значениями разделителей, которые присутствуют в маске
// при программном заполнении поля с заданной маской при начале редактирования данного поля 
// информация в ячейках, которые соответвуют разделителям, теряется
Функция ПрименитьМаску(Значение, Маска) Экспорт

	Результат = "";           
	ПерЦиклаЗначения = 1;
	
	Для ПерЦикла = 1 По СтрДлина(Маска) Цикл
		ТекСимволМаски  = Сред(Маска, ПерЦикла, 1);
		Если ПерЦиклаЗначения > СтрДлина(Значение) Тогда
			ТекСимволЗначения  = " ";
		Иначе
			ТекСимволЗначения  = Сред(Значение, ПерЦиклаЗначения, 1);
		КонецЕсли;
		                            
		Если (ТекСимволМаски = "!") ИЛИ (ТекСимволМаски = "@") Тогда
			ТекСимволЗначения = Врег(ТекСимволЗначения);
		ИначеЕсли ТекСимволМаски = "9" Тогда     
			Если ЭтоЦифра(ТекСимволЗначения) Тогда
				Если ПерЦиклаЗначения <= СтрДлина(Значение) Тогда
					ПерЦикла = ПерЦикла - 1;
				КонецЕсли;
			КонецЕсли;
		ИначеЕсли ТекСимволМаски = "#" Тогда     
			Если (ЭтоЦифра(ТекСимволЗначения)) И (ТекСимволЗначения <> "-")  И (ТекСимволЗначения <> "+")  
				И (ТекСимволЗначения <> " ")  Тогда
				Если ПерЦиклаЗначения <= СтрДлина(Значение) Тогда
					ПерЦикла = ПерЦикла - 1;
					ТекСимволЗначения = "";
				КонецЕсли;
			КонецЕсли;
		ИначеЕсли ТекСимволМаски = "N" Тогда     
			Если (ЭтоЦифра(ТекСимволЗначения)) И (ЭтоБуква(ТекСимволЗначения)) Тогда
				Если ПерЦиклаЗначения <= СтрДлина(Значение) Тогда
					ПерЦикла = ПерЦикла - 1;
					ТекСимволЗначения = "";
				КонецЕсли;
			КонецЕсли;
		ИначеЕсли ТекСимволМаски = "X" Тогда     
		Иначе
			ТекСимволЗначения = ТекСимволМаски; 
			ПерЦиклаЗначения = ПерЦиклаЗначения - 1;
		КонецЕсли;
		    
		Результат = Результат + ТекСимволЗначения;   
		ПерЦиклаЗначения = ПерЦиклаЗначения + 1;
	КонецЦикла;  
	
	Возврат Результат;
КонецФункции  
 
Функция ЭтоЦифра(С) Экспорт 
   Возврат Булево(Мин(СтрНайти("0123456789", С), 1));
КонецФункции  

Функция ЭтоРусскаяБуква(С) Экспорт 
   Возврат Булево(Мин(СтрНайти("АБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЫЬЪЭЮЯ", ВРег(С)), 1));
КонецФункции 
 
Функция ЭтоЛатинскаяБуква(С)Экспорт 
	Возврат Булево(Мин(СтрНайти("ABCDEFGHIJKLMNOPQRSTUVWXYZ", ВРег(С)),1));
КонецФункции

Функция ЭтоБуква(С)Экспорт
	Возврат Булево(Мин(ЭтоРусскаяБуква(С)+ ЭтоЛатинскаяБуква(С),1));
КонецФункции 

// Функция заменяет все не алфавитноцифровые символы на знак подчеркивания.
// Параметры
//  Код            - Строка, Значение кода, которое необходимо преобразовать.
// Возвращаемое значение
//  Строка, преобразованное значение кода.
//
Функция ВернутьАлфавитноЦифровоеПредставление(Код, РазрешитьЦифрыВНачале = Ложь, РазрешитьСлужебныеСимволы = Ложь, ЗаменятьНеправильные=Истина) Экспорт
	
	Если ТипЗнч(Код) <> Тип("Строка") Тогда
		Возврат Код;
	КонецЕсли;
	
	РусАлфавит       = "АБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ";
	ЛатАлфавит       = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
	Цифры            = "1234567890";
	СлужебныеСимволы = "\+.";
	
	ТекСтрока  = "";
	
	
	Инд = 1;
	ОбработкаНачала = Истина;
	Пока  Инд <= СтрДлина(Код) Цикл
		
		ТекСимвол = (Сред(Код, Инд, 1));
		
		Если  ОбработкаНачала Тогда
			Если СтрЧислоВхождений(РусАлфавит + ЛатАлфавит + ?(РазрешитьЦифрыВНачале, Цифры, "") + ?(РазрешитьСлужебныеСимволы, СлужебныеСимволы, ""), ВРЕГ(ТекСимвол)) <> 0 Тогда
				ОбработкаНачала = Ложь;
				ТекСтрока = ТекСтрока + ТекСимвол;
			КонецЕсли;
			
		Иначе
			
			Если СтрЧислоВхождений(РусАлфавит + ЛатАлфавит + Цифры + ?(РазрешитьСлужебныеСимволы, СлужебныеСимволы, "") + "_", ВРЕГ(ТекСимвол)) = 0 Тогда
				ТекСтрока = ТекСтрока + ?(ЗаменятьНеправильные,"_","");
			ИначеЕсли ТекСимвол = "/" И РазрешитьСлужебныеСимволы Тогда
				ТекСтрока = ТекСтрока + "\";
			Иначе
				ТекСтрока = ТекСтрока + ТекСимвол;
			КонецЕсли;
			
		КонецЕсли;
		
		Инд = Инд + 1;
		
	КонецЦикла;
	
	Возврат ТекСтрока;
КонецФункции


////////////ПреобразованиеДаты
//Начало//
#Область ПреобразованиеДаты

// Функция определяет наиболее верный вариант преобразования строки в дату и по нему отдает результат 
// Параметры
//  СтрокаДаты - Строка, Значение даты, которое необходимо преобразовать.
//  13.08_2020
//	2020-01-02
//	13.08-2020 23:59:59
//	2020-01-03 02-01-03
//	03:58:59 2020-01-02 
//	03:58:57 03-04-2020 
// Возвращаемое значение
//  Дата, преобразованное значение строки.
//
Функция Преобразование_ПолучитьДатуИзСтрокиПоСтандартнымФорматам(СтрокаДаты)Экспорт
	///___мкском___Козлов Иван Витальевич___2020/08/12___№№.№№___1 
	
	ПодготовленнаяСтрокаДаты = СтрЗаменить(Строка(СтрокаДаты), " ", "");
	ПодготовленнаяСтрокаДаты = СтрЗаменить(ПодготовленнаяСтрокаДаты, ".", "");
	ПодготовленнаяСтрокаДаты = СтрЗаменить(ПодготовленнаяСтрокаДаты, ",", "");
	ПодготовленнаяСтрокаДаты = СтрЗаменить(ПодготовленнаяСтрокаДаты, ":", "");
	ПодготовленнаяСтрокаДаты = СтрЗаменить(ПодготовленнаяСтрокаДаты, "-", "");
	ПодготовленнаяСтрокаДаты = СтрЗаменить(ПодготовленнаяСтрокаДаты, "/", "");
	ПодготовленнаяСтрокаДаты = СтрЗаменить(ПодготовленнаяСтрокаДаты, "_", "");
	ПодготовленнаяСтрокаДаты = СтрЗаменить(ПодготовленнаяСтрокаДаты, "\", "");
	ПодготовленнаяСтрокаДаты = СтрЗаменить(ПодготовленнаяСтрокаДаты, "=", "");
	ПодготовленнаяСтрокаДаты = СтрЗаменить(ПодготовленнаяСтрокаДаты, "+", "");
	ПодготовленнаяСтрокаДаты = СтрЗаменить(ПодготовленнаяСтрокаДаты, ";", "");
	ПодготовленнаяСтрокаДаты = СтрЗаменить(ПодготовленнаяСтрокаДаты, ""+Символы.ПС, "");
	ПодготовленнаяСтрокаДаты = СтрЗаменить(ПодготовленнаяСтрокаДаты, ""+Символы.НПП, "");
	
	ДлинаДаты = СтрДлина(ПодготовленнаяСтрокаДаты); 
	ДатаЧитаемаяСлева = ПодготовленнаяСтрокаДаты;	
	
	Если ДлинаДаты < 8 Тогда
		
		Если НЕ ДлинаДаты%2 = 0 Тогда
			//Не поддерживается ! 1.12.20. Преобразуем к 01.12.2020
			ДатаЧитаемаяСлева = "0" + ДатаЧитаемаяСлева;
		КонецЕсли;
		
		Если ДлинаДаты = 2 Тогда
			//Есть день 
			ДатаЧитаемаяСлева = ДатаЧитаемаяСлева + Формат(ТекущаяДата(), "ДФ=MMyyyy");
		ИначеЕсли ДлинаДаты = 4 Тогда
			//Есть месяц
			ДатаЧитаемаяСлева = ДатаЧитаемаяСлева + Формат(ТекущаяДата(), "ДФ=yyyy");
		ИначеЕсли ДлинаДаты = 6 Тогда 
			//Есть часть года

			ДатаЧитаемаяСлева = Лев(ДатаЧитаемаяСлева,4) + Сред(Формат(ТекущаяДата(), "ДФ=yyyy"),0,2) + Сред(ДатаЧитаемаяСлева, ДлинаДаты-1,2);		
		КонецЕсли; 
		
		ДлинаДаты = СтрДлина(ДатаЧитаемаяСлева);
	КонецЕсли; 
	
	ЕстьВремя = Ложь;
	Если ДлинаДаты > 8 Тогда
		ЕстьВремя = Истина;	
	КонецЕсли; 
	
	Если ДлинаДаты < 14 Тогда
		
		Для Итератор = ДлинаДаты По (14-1) Цикл
			ДатаЧитаемаяСлева = ДатаЧитаемаяСлева + "0";
		КонецЦикла; 	
	КонецЕсли; 
	
	//Слева на право  СтрДлина(ДатаЧитаемаяСлева)
	ДатаРезультат = Неопределено;
			
	ДатаРезультат = Преобразование_СкомпановатьДатуИзСтроки(ДатаЧитаемаяСлева, ЕстьВремя, Истина, Истина, Истина); //Всё слева на право. Год слева
	Если НЕ ДатаРезультат = Неопределено Тогда
		Возврат ДатаРезультат;	
	КонецЕсли; 
	
	ДатаРезультат = Преобразование_СкомпановатьДатуИзСтроки(ДатаЧитаемаяСлева, ЕстьВремя, Истина, Ложь, Истина); //Год наоборот
	Если НЕ ДатаРезультат = Неопределено Тогда
		Возврат ДатаРезультат;	
	КонецЕсли;
	
	ДатаРезультат = Преобразование_СкомпановатьДатуИзСтроки(ДатаЧитаемаяСлева, ЕстьВремя, Истина, Истина, Ложь); //Часы ноборот
	Если НЕ ДатаРезультат = Неопределено Тогда
		Возврат ДатаРезультат;	
	КонецЕсли;
	
	ДатаРезультат = Преобразование_СкомпановатьДатуИзСтроки(ДатаЧитаемаяСлева, ЕстьВремя, Истина, Ложь, Ложь); //Год и часы наоборот
	Если НЕ ДатаРезультат = Неопределено Тогда
		Возврат ДатаРезультат;	
	КонецЕсли;
	
	ДатаРезультат = Преобразование_СкомпановатьДатуИзСтроки(ДатаЧитаемаяСлева, ЕстьВремя, Ложь, Ложь, Истина); //Год справа. Часы слева
	Если НЕ ДатаРезультат = Неопределено Тогда
		Возврат ДатаРезультат;	
	КонецЕсли;
	
	ДатаРезультат = Преобразование_СкомпановатьДатуИзСтроки(ДатаЧитаемаяСлева, ЕстьВремя, Ложь, Ложь, Ложь); //Всё наоборот. Год справа
	Если НЕ ДатаРезультат = Неопределено Тогда
		Возврат ДатаРезультат;	
	КонецЕсли;
	
	ДатаРезультат = Преобразование_СкомпановатьДатуИзСтроки(ДатаЧитаемаяСлева, ЕстьВремя, Ложь, Истина, Истина);
	Если НЕ ДатаРезультат = Неопределено Тогда
		Возврат ДатаРезультат;	
	КонецЕсли;				
	
	ДатаРезультат = Преобразование_СкомпановатьДатуИзСтроки(ДатаЧитаемаяСлева, ЕстьВремя, Ложь, Истина, Ложь);
	Если НЕ ДатаРезультат = Неопределено Тогда
		Возврат ДатаРезультат;	
	КонецЕсли;
		
	Возврат ДатаРезультат;	
КонецФункции

Функция Преобразование_СкомпановатьДатуИзСтроки(ПреобразуемаяСтрока, ЕстьВремя, НачатьСлева = Истина, ГодСлеваНаПраво = Истина, ЧасыСлеваНаПраво = Истина)
	//Просто о сложном. Перемешиваем и преобразуем дату 	
	
	Если НачатьСлева Тогда 
		
		ЧастьГодМесяцДень = Лев(ПреобразуемаяСтрока, 8);
		ЧастьЧасМинутаСекунда = Сред(ПреобразуемаяСтрока,9, 6);
	Иначе
		Если ЕстьВремя Тогда
			ЧастьГодМесяцДень = Сред(ПреобразуемаяСтрока, 7, 9);
			ЧастьЧасМинутаСекунда = Лев(ПреобразуемаяСтрока,6);	
		Иначе
			//Если времени не задано - всегда начинать слева
			ЧастьГодМесяцДень = Лев(ПреобразуемаяСтрока, 8);
			ЧастьЧасМинутаСекунда = Сред(ПреобразуемаяСтрока,9, 6);	
		КонецЕсли; 
	КонецЕсли; 
	
	//yyyy MM dd
	СчетчикУказатель = 0;
	Если ГодСлеваНаПраво Тогда
		Год = Сред(ЧастьГодМесяцДень, СчетчикУказатель,4);		
		СчетчикУказатель = СчетчикУказатель + 4+1;
	Иначе
		СчетчикУказатель = СтрДлина(ЧастьГодМесяцДень)-4+1;
		Год = Сред(ЧастьГодМесяцДень,СчетчикУказатель,4);
	КонецЕсли; 
	
	Если ГодСлеваНаПраво Тогда
		Месяц = Сред(ЧастьГодМесяцДень, СчетчикУказатель,2);
	    СчетчикУказатель = СчетчикУказатель + 2; 
	Иначе
		СчетчикУказатель = СчетчикУказатель-2;
		Месяц = Сред(ЧастьГодМесяцДень,СчетчикУказатель,2);		
	КонецЕсли; 
	
	Если ГодСлеваНаПраво Тогда
		День = Сред(ЧастьГодМесяцДень, СчетчикУказатель,2);
	    СчетчикУказатель = СчетчикУказатель + 2; 
	Иначе
		СчетчикУказатель = СчетчикУказатель-2;
		День = Сред(ЧастьГодМесяцДень,СчетчикУказатель,2);		
	КонецЕсли; 
	
	//чч мм сс
	СчетчикУказатель = 0;
	Если ЧасыСлеваНаПраво Тогда
		Час = Сред(ЧастьЧасМинутаСекунда, СчетчикУказатель,2);
	    СчетчикУказатель = СчетчикУказатель + 2+1; 
	Иначе
		СчетчикУказатель = СтрДлина(ЧастьЧасМинутаСекунда)-2+1;
		Час = Сред(ЧастьЧасМинутаСекунда,СчетчикУказатель,2);		
	КонецЕсли; 

	Если ЧасыСлеваНаПраво Тогда
		Минута = Сред(ЧастьЧасМинутаСекунда, СчетчикУказатель,2);
	    СчетчикУказатель = СчетчикУказатель + 2; 
	Иначе
		СчетчикУказатель = СчетчикУказатель-2;
		Минута = Сред(ЧастьЧасМинутаСекунда,СчетчикУказатель,2);		
	КонецЕсли; 
	
	Если ЧасыСлеваНаПраво Тогда
		Секунда = Сред(ЧастьЧасМинутаСекунда, СчетчикУказатель,2);
	    СчетчикУказатель = СчетчикУказатель + 2; 
	Иначе
		СчетчикУказатель = СчетчикУказатель-2;
		Секунда = Сред(ЧастьЧасМинутаСекунда,СчетчикУказатель,2);		
	КонецЕсли;
		
	//Проверить полученные компоненты 
	РезультатПроверки = Преобразование_ПроверитьКомпонентДаты(Год, 3999, 1900);
	Если РезультатПроверки = Ложь Тогда
		Возврат Неопределено;	
	КонецЕсли; 
	
	РезультатПроверки = Преобразование_ПроверитьКомпонентДаты(Месяц, 12);
	Если РезультатПроверки = Ложь Тогда
		Возврат Неопределено;	
	КонецЕсли;
	
	РезультатПроверки = Преобразование_ПроверитьКомпонентДаты(День, 31);
	Если РезультатПроверки = Ложь Тогда
		Возврат Неопределено;	
	КонецЕсли;

	РезультатПроверки = Преобразование_ПроверитьКомпонентДаты(Час, 23);
	Если РезультатПроверки = Ложь Тогда
		Возврат Неопределено;	
	КонецЕсли;

	РезультатПроверки = Преобразование_ПроверитьКомпонентДаты(Минута, 59);
	Если РезультатПроверки = Ложь Тогда
		Возврат Неопределено;	
	КонецЕсли;

	РезультатПроверки = Преобразование_ПроверитьКомпонентДаты(Секунда, 59);
	Если РезультатПроверки = Ложь Тогда
		Возврат Неопределено;	
	КонецЕсли;
	
	//Формирование строки
	Преобразование_ЗаменитьНулевуюДату(Месяц, "01");
	Преобразование_ЗаменитьНулевуюДату(День, "01");
	
	ПодготовленнаяСтрокаДаты = "" + Год + Месяц + День + Час + Минута + Секунда; 
	//ДатаПреобр = ДатаПреобр + Символы.ПС + ПодготовленнаяСтрокаДаты; //Для тестов

	//Преобразовать дату 
	ДатаРезультат = Неопределено; 	
	Попытка
		ДатаРезультат = Дата(ПодготовленнаяСтрокаДаты); 
	Исключение
	КонецПопытки;
	
	Возврат ДатаРезультат;
КонецФункции

Функция Преобразование_ПроверитьКомпонентДаты(КомпонентСтрока, ЧисловойПределМакс, ЧисловойПределМин = 0)
	//Проверка параметров даты
	
	Попытка
		КомпонентЧисло = Число(КомпонентСтрока);
		Если КомпонентЧисло > ЧисловойПределМакс Тогда
			Возврат Ложь;	
		КонецЕсли; 
		
		Если КомпонентЧисло < ЧисловойПределМин И ЧисловойПределМин > 0 Тогда
			Возврат Ложь;	
		КонецЕсли; 
	Исключение
		Возврат Ложь;
	КонецПопытки; 
	
	Возврат Истина;
КонецФункции

Процедура Преобразование_ЗаменитьНулевуюДату(КомпонентСтрока, СтрокаЗамены)
	//Брать превый месяц и день, если их нет 
	Если КомпонентСтрока = "00" Тогда
		КомпонентСтрока = СтрокаЗамены;	
	КонецЕсли; 	
КонецПроцедуры

#КонецОбласти
//Конец//
////////////ПреобразованиеДаты 


////////////ПреобразованиеБулево
//Начало//
#Область ПреобразованиеБулево

// Функция получает булево из строки, согласно не стандартной логике.
// Параметры
//  СтрокаБулево            - Строка, любая строка, значение которой необходимо преобразовать в булево.
//  ПриоритетИстины         - Булево, Истина - всегда выдавать "истину", а "ложь" по правилам. Ложь - всегда выдавать "ложь", а "истину" по правилам
// Возвращаемое значение
//  Булево, итоговое значение преобразования строки.
//
Функция Преобразование_ПолучитьБулевоИзСтроки(СтрокаБулево, ПриоритетИстины = Истина)Экспорт
	///___мкском___Козлов Иван Витальевич___2020/08/13___№№.№№___1 
	
	ПолготовленнаяСтрокаБулево = СтрЗаменить(Строка(СтрокаБулево), ":", "");
	ПолготовленнаяСтрокаБулево = СтрЗаменить(ПолготовленнаяСтрокаБулево, "/", "");
	ПолготовленнаяСтрокаБулево = СтрЗаменить(ПолготовленнаяСтрокаБулево, "_", "");
	ПолготовленнаяСтрокаБулево = СтрЗаменить(ПолготовленнаяСтрокаБулево, "\", "");
	ПолготовленнаяСтрокаБулево = СтрЗаменить(ПолготовленнаяСтрокаБулево, "=", "");
	ПолготовленнаяСтрокаБулево = СтрЗаменить(ПолготовленнаяСтрокаБулево, ";", "");
	ПолготовленнаяСтрокаБулево = СтрЗаменить(ПолготовленнаяСтрокаБулево, ""+Символы.ПС, "");
	ПолготовленнаяСтрокаБулево = СтрЗаменить(ПолготовленнаяСтрокаБулево, ""+Символы.НПП, "");

	ПолготовленнаяСтрокаБулево = НРег(ПолготовленнаяСтрокаБулево);
	ПолготовленнаяСтрокаБулево = СокрЛП(ПолготовленнаяСтрокаБулево);
	
	Если НЕ ЗначениеЗаполнено(ПолготовленнаяСтрокаБулево) Тогда
		//Пустые значения это ложь
		Возврат Ложь;	
	КонецЕсли;
	
	//Числа конвертировать согласно логике 1С 
	Попытка
		РезультатЧислом = Число(ПолготовленнаяСтрокаБулево);
		
		Стр1 = Формат(РезультатЧислом,"ЧН=0; ЧГ=");
		Стр2 = СтрЗаменить(Строка(ПолготовленнаяСтрокаБулево), " ", "");
		
		Если Найти(Стр2, Стр1) > 0 Тогда
			
			Если РезультатЧислом > 0 Тогда
				Возврат Истина;
			Иначе
				Возврат Ложь;
			КонецЕсли; 	
		КонецЕсли; 
	Исключение
	    //ОписаниеОшибки()
	КонецПопытки; 

	Если ПриоритетИстины Тогда
		//Приоритет истина 
			
		Если Найти(ПолготовленнаяСтрокаБулево, "ложь") > 0
			ИЛИ Найти(ПолготовленнаяСтрокаБулево, "false") > 0
			ИЛИ Найти(ПолготовленнаяСтрокаБулево, "-") > 0
			ИЛИ Найти(ПолготовленнаяСтрокаБулево, "нет") > 0
			ИЛИ Найти(ПолготовленнаяСтрокаБулево, "no") > 0
			ИЛИ Найти(ПолготовленнаяСтрокаБулево, "плохо") > 0
			ИЛИ Найти(ПолготовленнаяСтрокаБулево, "сломано") > 0
			ИЛИ Найти(ПолготовленнаяСтрокаБулево, "не ") > 0
			Тогда
			//Ложь только для описанных случаев 
			
			Возврат Ложь;
		Иначе
			//А истина всегда
			Возврат Истина;
		КонецЕсли; 		
	Иначе
		//Приоритет ложь

		Если Найти(ПолготовленнаяСтрокаБулево, "истина") > 0
			ИЛИ Найти(ПолготовленнаяСтрокаБулево, "true") > 0
			ИЛИ Найти(ПолготовленнаяСтрокаБулево, "+") > 0
			ИЛИ Найти(ПолготовленнаяСтрокаБулево, "да") > 0
			ИЛИ Найти(ПолготовленнаяСтрокаБулево, "yes") > 0
			ИЛИ Найти(ПолготовленнаяСтрокаБулево, "ок") > 0
			ИЛИ Найти(ПолготовленнаяСтрокаБулево, "хорошо") > 0
			ИЛИ Найти(ПолготовленнаяСтрокаБулево, "пригодно") > 0
			ИЛИ Найти(ПолготовленнаяСтрокаБулево, "отлично") > 0
			ИЛИ Найти(ПолготовленнаяСтрокаБулево, "сделано") > 0
			ИЛИ Найти(ПолготовленнаяСтрокаБулево, "выполнено") > 0
			Тогда
			//Истина только для описанных случаев 		
		Иначе
			//А ложь всегда 
			Возврат Ложь;	
		КонецЕсли; 
	КонецЕсли; 	
КонецФункции

#КонецОбласти
//Конец//
////////////ПреобразованиеБулево 

