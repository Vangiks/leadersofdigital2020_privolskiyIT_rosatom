
#Область Работа_со_схемами_запросов

Функция ПолучитьВыражениеПоляПоПсевдониму(ЗапросПакет, Псевдоним, ИндексОператора = 0) Экспорт
	
	ИндексКолонки = ПолучитьИндексКолонкиПакетаЗапросаПоПсевдониму(ЗапросПакет, Псевдоним);
	
	Если ИндексКолонки > -1 Тогда
		Оператор = ЗапросПакет.Операторы.Получить(ИндексОператора);
		
		Возврат Строка(Оператор.ВыбираемыеПоля[ИндексКолонки]);
	КонецЕсли;
	
	Возврат "";
	
КонецФункции

Процедура ИзменитьВыражениеУПоляПоПсевдониму(ЗапросПакет, Псевдоним, НовоеВыражение, ИндексОператора = 0) Экспорт
	
	ИндексКолонки = ПолучитьИндексКолонкиПакетаЗапросаПоПсевдониму(ЗапросПакет, Псевдоним);
	Если ИндексКолонки > -1 Тогда
		Оператор = ЗапросПакет.Операторы.Получить(ИндексОператора);
		Оператор.ВыбираемыеПоля.Добавить(НовоеВыражение, ИндексКолонки);
	КонецЕсли;
	
КонецПроцедуры

Функция ПолучитьИндексКолонкиПакетаЗапросаПоПсевдониму(ЗапросПакет, Псевдоним) Экспорт
	
	Колонка = ЗапросПакет.Колонки.Найти(Псевдоним);
	Если Колонка = Неопределено Тогда
		Возврат -1;
	КонецЕсли;
	
	Возврат ЗапросПакет.Колонки.Индекс(Колонка);
	
КонецФункции

Функция ДобавитьЗапросПолногоСоединенияКОсновнойТаблице(СхемаЗапроса, ЗапросОсновнойТаблицы, КлючевыеПоляПрисоединяемыхТаблиц) Экспорт
	
	ЗапросПакет = СхемаЗапроса.ПакетЗапросов.Добавить(Тип("ЗапросВыбораСхемыЗапроса"));
	Оператор = ЗапросПакет.Операторы.Получить(0);
	
	// добавим основную таблицу (левую) и выбор всех полей из нее
	ИмяОсновнойТаблицы = ЗапросОсновнойТаблицы.ТаблицаДляПомещения;
	ИсточникОсновнаяВТ = Оператор.Источники.Добавить(ИмяОсновнойТаблицы);
	Для Каждого Колонка Из ЗапросОсновнойТаблицы.Колонки Цикл
		Оператор.ВыбираемыеПоля.Добавить(ИмяОсновнойТаблицы + "." + Колонка.Псевдоним);
	КонецЦикла;
	
	// присоединим остальные таблицы и добавим выбор ключевого поля из них
	Инд = 0;
	Для Каждого ИмяПоля Из КлючевыеПоляПрисоединяемыхТаблиц Цикл
		ИмяВТ = "вт" + ИмяПоля;
		
		ИсточникПрисоединяемаяВт = Оператор.Источники.Добавить(ИмяВТ);
		Оператор.ВыбираемыеПоля.Добавить(ИмяВТ + "." + ИмяПоля);
		ИсточникОсновнаяВТ.Соединения.Добавить(ИсточникПрисоединяемаяВт, "ИСТИНА");
		
		Инд = Инд + 1;
	КонецЦикла;
	
	Возврат ЗапросПакет;
	
КонецФункции

// необходимо вызывать при программном добавлении нового источника в схему запроса
// иначе создаются соединения по умолчанию, которые не нужны (например по полю "Ссылка" с полем такого же типа)
Процедура ОчиститьЛишниеСоединенияПриДобавленииТаблицыВСхемуЗапроса(ИсточникДобавляемаяТаблица, Оператор) Экспорт
	
	ИсточникДобавляемаяТаблица.Соединения.Очистить();
	
	Для Каждого Источник Из Оператор.Источники Цикл
		Если Источник <> ИсточникДобавляемаяТаблица Тогда
			УдалитьСоединениеПоПсевдонимуТаблицы(Источник, ИсточникДобавляемаяТаблица.Источник.Псевдоним);
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

Процедура УдалитьСоединениеПоПсевдонимуТаблицы(Источник, ПсевдонимТаблицы) Экспорт
	
	Соединение = Источник.Соединения.НайтиПоПсевдониму(ПсевдонимТаблицы);
	
	Если Соединение = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	Источник.Соединения.Удалить(Источник.Соединения.Индекс(Соединение));
	
КонецПроцедуры

Процедура ДобавитьОтборВЗапросПакетаСхемы(ЗапросПакета, Отбор) Экспорт
	
	Если ТипЗнч(Отбор) = Тип("Строка") Тогда
		Отбор = ОбщегоНазначенияКлиентСервер.ЗначениеВМассиве(Отбор);
	КонецЕсли;
	
	Оператор = ЗапросПакета.Операторы.Получить(0);
	
	Для Каждого ВыражениеОтбора Из Отбор Цикл
		Оператор.Отбор.Добавить(ВыражениеОтбора);
	КонецЦикла;
	
КонецПроцедуры

Функция СформироватьТекстЗапросаПолногоСоединенияКОсновнойТаблице(ИмяОсновнойТаблицы, МассивИменПрисоединяемыхТаблиц, ИмяВТДляПомещения = "") Экспорт
	
	ТекстЗапроса =
		"ВЫБРАТЬ
		|*
		|	" + ?(ПустаяСтрока(ИмяВТДляПомещения), "", "ПОМЕСТИТЬ " + ИмяВТДляПомещения) + "
		|ИЗ
		|	" + ИмяОсновнойТаблицы + " КАК " + ИмяОсновнойТаблицы;
	
	Для Каждого ИмяВТ Из МассивИменПрисоединяемыхТаблиц Цикл
		ТекстЗапроса = ТекстЗапроса + "
		|		ЛЕВОЕ СОЕДИНЕНИЕ " + ИмяВТ + " КАК " + ИмяВТ + "
		|		ПО ИСТИНА";
	КонецЦикла;
	
	Возврат ТекстЗапроса;
	
КонецФункции

Функция ПолучитьРезультатИерархическогоЗапросаКТаблицеЗначений(ТаблицаИсточник, Знач ПоляГруппировок = "", Знач ПоляИтогов = "") Экспорт
	
	Если ТипЗнч(ПоляГруппировок) = Тип("Строка") Тогда
		ПоляГруппировок = СтрРазделить(ПоляГруппировок, ", ", Ложь);
	КонецЕсли;
	
	Если ТипЗнч(ПоляИтогов) = Тип("Строка") Тогда
		ПоляИтогов = СтрРазделить(ПоляИтогов, ", ", Ложь);
	КонецЕсли;
	
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("пТаблицаИсточник", ТаблицаИсточник);
	
	СхемаЗапроса = Новый СхемаЗапроса;
	
	
	// первый пакет
	ЗапросВыборИзПараметрическойТаблицы = СхемаЗапроса.ПакетЗапросов.Добавить(Тип("ЗапросВыбораСхемыЗапроса"));
	ЗапросВыборИзПараметрическойТаблицы.ТаблицаДляПомещения = "втТаблицаИсточник";
	
	ОператорПарам = ЗапросВыборИзПараметрическойТаблицы.Операторы.Получить(0);
	ОператорПарам.Источники.Добавить(Тип("ОписаниеВременнойТаблицыСхемыЗапроса"), "&пТаблицаИсточник", "пТаблицаИсточник");
	
	
	// второй пакет
	ЗапросРезультат = СхемаЗапроса.ПакетЗапросов.Добавить(Тип("ЗапросВыбораСхемыЗапроса"));
	
	ОператорРез = ЗапросРезультат.Операторы.Получить(0);
	ОператорРез.Источники.Добавить("втТаблицаИсточник");
	
	
	// выбираемые поля
	Для Каждого Колонка Из ТаблицаИсточник.Колонки Цикл
		
		ОператорПарам.ВыбираемыеПоля.Добавить("пТаблицаИсточник." + Колонка.Имя);
		ОператорРез.ВыбираемыеПоля.Добавить("втТаблицаИсточник." + Колонка.Имя);
		
	КонецЦикла;
	
	
	// группировки и итоги
	Для Каждого ПолеГруппировки Из ПоляГруппировок Цикл
		ЗапросРезультат.КонтрольныеТочкиИтогов.Добавить(ПолеГруппировки);
	КонецЦикла;
	
	Для Каждого ПолеИтога Из ПоляИтогов Цикл
		ЗапросРезультат.ВыраженияИтогов.Добавить(ПолеИтога);
	КонецЦикла;
	
	
	Запрос.Текст = СхемаЗапроса.ПолучитьТекстЗапроса();
	
	Возврат Запрос.Выполнить();
	
КонецФункции

Функция ОбъединитьТекстЗапросаСоСхемой(СхемаЗапроса, ТекстЗапроса, СначалаСхема = Истина) Экспорт
	
	МассивТекстов = Новый Массив;
	МассивТекстов.Добавить(СхемаЗапроса.ПолучитьТекстЗапроса());
	
	Если СначалаСхема Тогда
		МассивТекстов.Добавить(ТекстЗапроса);
	Иначе
		МассивТекстов.Вставить(0, ТекстЗапроса);
	КонецЕсли;
	
	Разделитель = "
		|;
		|
		|////////////////////////////////////////////////////////////////////////////////
		|";
	
	Возврат СтрСоединить(МассивТекстов, Разделитель);
	
КонецФункции

#КонецОбласти

#Область Программное_построение_СКД

Функция ДобавитьПодчиненнуюГруппировкуКомпоновкиДанных(Родитель) Экспорт
	
	ТипРодителя = ТипЗнч(Родитель);
	
	Если ТипРодителя = Тип("КоллекцияЭлементовСтруктурыТаблицыКомпоновкиДанных") Тогда
		НоваяГруппировка = Родитель.Добавить();
		
	ИначеЕсли ТипРодителя = Тип("ГруппировкаТаблицыКомпоновкиДанных") Тогда
		НоваяГруппировка = Родитель.Структура.Добавить();
		
	Иначе
		НоваяГруппировка = Родитель.Структура.Добавить(Тип("ГруппировкаКомпоновкиДанных"));
		
	КонецЕсли;
	
	Возврат НоваяГруппировка;
	
КонецФункции

Процедура ДобавитьПолеГруппировкиКомпоновкиДанных(Группировка, ИмяПоля, Использование = Истина) Экспорт
	
	НовоеПолеГруппировки = Группировка.ПоляГруппировки.Элементы.Добавить(Тип("ПолеГруппировкиКомпоновкиДанных"));
	НовоеПолеГруппировки.Использование = Использование;
	НовоеПолеГруппировки.Поле = Новый ПолеКомпоновкиДанных(ИмяПоля);
	
КонецПроцедуры

Процедура ДобавитьВыбранноеПолеКомпоновкиДанныхВГруппировку(Группировка, ИмяПоля = "") Экспорт
	
	Если ИмяПоля = "" Тогда
		ВыбранноеПоле = Группировка.Выбор.Элементы.Добавить(Тип("АвтоВыбранноеПолеКомпоновкиДанных"));
	Иначе
		ВыбранноеПоле = Группировка.Выбор.Элементы.Добавить(Тип("ВыбранноеПолеКомпоновкиДанных"));
		ВыбранноеПоле.Поле = Новый ПолеКомпоновкиДанных(ИмяПоля);
	КонецЕсли;
	
	ВыбранноеПоле.Использование = Истина;
	
КонецПроцедуры

Процедура ДобавитьПолеПорядкаКомпоновкиДанных(Группировка, ИмяПоля, Направление = "Возр") Экспорт
	
	НовоеПолеПорядкаГруппировки = Группировка.Порядок.Элементы.Добавить(Тип("ЭлементПорядкаКомпоновкиДанных"));
	НовоеПолеПорядкаГруппировки.Использование = Истина;
	НовоеПолеПорядкаГруппировки.Поле = Новый ПолеКомпоновкиДанных(ИмяПоля);
	НовоеПолеПорядкаГруппировки.ТипУпорядочивания = НаправлениеСортировкиКомпоновкиДанных[Направление];
	
КонецПроцедуры

Процедура ДобавитьПолеИтога(СКД, ПутьКДанным, Группировки = "", Выражение = "") Экспорт
	
	ПолеИтога = СКД.ПоляИтога.Добавить();
	ПолеИтога.ПутьКДанным = ПутьКДанным;
	ПолеИтога.Выражение = ?(ПустаяСтрока(Выражение), ПутьКДанным, Выражение);
	
	Если ПустаяСтрока(Группировки) Тогда
		Возврат;
	КонецЕсли;
	
	Если ТипЗнч(Группировки) = Тип("Строка") Тогда
		Группировки = СтрРазделить(Группировки, ",", Ложь);
	КонецЕсли;
	
	Для Каждого Группировка Из Группировки Цикл
		ПолеИтога.Группировки.Добавить(Группировка);
	КонецЦикла;
	
КонецПроцедуры

Процедура УстановитьПараметрыСКД(СКД, Параметры) Экспорт
	
	Для Каждого КлючЗначениеПараметра Из Параметры Цикл
		
		ПараметрСхемыКомпоновкиДанных = СКД.Параметры.Найти(КлючЗначениеПараметра.Ключ);
		
		Если ПараметрСхемыКомпоновкиДанных <> Неопределено Тогда 
			
			ПараметрСхемыКомпоновкиДанных.Значение = КлючЗначениеПараметра.Значение;
			
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

#КонецОбласти

#Область Вывод_ТабДок

Процедура ВыводСКД(СхемаКомпоновкиДанных, НастройкиСКД, ДокументРезультат, тзРезультат = Неопределено, УровеньГруппировок = Неопределено, ИмяОбъектаДанных = Неопределено, Отказ = Ложь) Экспорт
	
	КомпоновщикМакета = Новый КомпоновщикМакетаКомпоновкиДанных;
	МакетКомпоновки = КомпоновщикМакета.Выполнить(СхемаКомпоновкиДанных, НастройкиСКД);
	ПроцессорКомпоновки = Новый ПроцессорКомпоновкиДанных;
	
	Если тзРезультат = Неопределено Тогда
		ПроцессорКомпоновки.Инициализировать(МакетКомпоновки);
	Иначе
		Если ИмяОбъектаДанных = Неопределено Тогда
			ИмяОбъектаДанных = "тзРезультат";
		КонецЕсли;
		ВнешнийИсточникДанных = Новый Структура(ИмяОбъектаДанных, тзРезультат);
		ПроцессорКомпоновки.Инициализировать(МакетКомпоновки, ВнешнийИсточникДанных);
	КонецЕсли;
	
	ПроцессорВывода = Новый ПроцессорВыводаРезультатаКомпоновкиДанныхВТабличныйДокумент;
	ПроцессорВывода.УстановитьДокумент(ДокументРезультат);
	
	Попытка
		ПроцессорВывода.Вывести(ПроцессорКомпоновки);
	Исключение
		ОбщегоНазначения.СообщитьПользователю(ОписаниеОшибки(),,,, Отказ);
		ДокументРезультат.Очистить();
		Возврат;
	КонецПопытки;
	
	Если УровеньГруппировок <> Неопределено Тогда
		ДокументРезультат.ПоказатьУровеньГруппировокСтрок(УровеньГруппировок);
	КонецЕсли;
	
КонецПроцедуры

// подгоняет щирину колонок под размер текста в них (не идеально)
Процедура РасчетШириныКолонок(ТабличныйДокумент, ВыводимаяОбласть, НачальнаяКолонка = 1) Экспорт
	
	Перем МаксимальнаяШиринаКолонки;
	Перем КонечнаяСтрока, ТекущаяКолонка, ТекущаяСтрока;
	Перем ОбластьШапки, ОбластьПодвала;
	Перем ШиринаКолонки, ТекстЯчейки, НомерСтрокиТекста;
	Перем КоличествоУровнейГруппировокСтрок, Отступ;
	Перем ШириныКолонок;
	
	ВыводимаяОбласть.СоздатьФорматСтрок();
	
	// Ограничение максимальной ширины колонки 
	МаксимальнаяШиринаКолонки = 50;
	// Массив, в который будут помещаться ширины колонок 
	ШириныКолонок = Новый Массив;
	// Получим количество уровней группировок в отчете для учета автоматического отступа
	КоличествоУровнейГруппировокСтрок = ТабличныйДокумент.КоличествоУровнейГруппировокСтрок();
	
	
	// Инициализируем начальные и конечные строки
	НачальнаяСтрока = ВыводимаяОбласть.Верх;
	КонечнаяСтрока = ТабличныйДокумент.ВысотаТаблицы;
	
	// Переберем все колонки отчета 
	Для ТекущаяКолонка = НачальнаяКолонка По ТабличныйДокумент.ШиринаТаблицы Цикл
		
		АвтоОтступ = 0;
		
		// Переберем строки, которые будут использованы для расчета ширин колонок
		Для ТекущаяСтрока = НачальнаяСтрока По КонечнаяСтрока Цикл
			
			ШиринаКолонки = 0;
			
			// Получим область текущей ячейки
			ОбластьЯчейки = ТабличныйДокумент.Область(ТекущаяСтрока, ТекущаяКолонка);
			
			Если ОбластьЯчейки.Лево <> ТекущаяКолонка Или ОбластьЯчейки.Верх <> ТекущаяСтрока Тогда
				
				// Данная ячейка принадлежит объединенным ячейкам и не является начальной ячейкой
				Продолжить;
				
			КонецЕсли;
			
			Если КоличествоУровнейГруппировокСтрок > 0 И ТекущаяСтрока = НачальнаяСтрока Тогда
				
				// Для первой строки с данными получим значение автоотступа
				АвтоОтступ = ОбластьЯчейки.АвтоОтступ;
				
			КонецЕсли;
			
			// Получим текст ячейки
			ТекстЯчейки = ОбластьЯчейки.Текст;
			
			// Для каждой строки из текста ячейки рассчитаем количество символов в строке
			Для НомерСтрокиТекста = 1 По СтрЧислоСтрок(ТекстЯчейки) Цикл
				
				ШиринаТекстаЯчейки = СтрДлина(СтрПолучитьСтроку(СокрЛП(ТекстЯчейки), НомерСтрокиТекста));
				
				// Если используется автоотступ, то прибавим к ширине ячейки его величину
				Если АвтоОтступ <> Неопределено И АвтоОтступ > 0 Тогда
					
					ШиринаТекстаЯчейки = ШиринаТекстаЯчейки + КоличествоУровнейГруппировокСтрок * АвтоОтступ;
					
				КонецЕсли;
				
				ШиринаКолонки = Макс(ШиринаКолонки, ШиринаТекстаЯчейки);
				
			КонецЦикла;
			
			Если ШиринаКолонки > МаксимальнаяШиринаКолонки Тогда
				
				// Ограничим ширину колонки
				ШиринаКолонки = МаксимальнаяШиринаКолонки;
			КонецЕсли;
			
			Если ШиринаКолонки <> 0 Тогда
				// Ширина колонки рассчитана
				
				// Определим, сколько ячеек по ширине используется в области для текущей ячейки
				КоличествоКолонок = ОбластьЯчейки.Право - ОбластьЯчейки.Лево;
				
				// Переберем все ячейки, расположенные в области
				Для НомерКолонки = 0 По КоличествоКолонок Цикл
					
					Если ШириныКолонок.ВГраница() > ТекущаяКолонка - 1 + НомерКолонки Тогда
						
						// В массиве ширин колонок уже был элемент для текущей колонки
						
						Если ШириныКолонок[ТекущаяКолонка - 1 + НомерКолонки] = Неопределено Тогда
							// Значение ширины колонки еще не было установлено
							
							ШириныКолонок[ТекущаяКолонка - 1 + НомерКолонки] = ШиринаКолонки / (КоличествоКолонок + 1);
							
						Иначе
							// Значение ширины колонки уже было установлено
							// Вычислим максимум ширины колонки
							ШириныКолонок[ТекущаяКолонка - 1 + НомерКолонки] =
							Макс(ШириныКолонок[ТекущаяКолонка - 1 + НомерКолонки], ШиринаКолонки / (КоличествоКолонок + 1));
							
						КонецЕсли; 
						
					Иначе 
						
						// В массиве ширин колонок еще не было элемента для данной колонки
						// Добавим элемент в массив ширин колонок
						ШириныКолонок.Вставить(ТекущаяКолонка - 1 + НомерКолонки, ШиринаКолонки / (КоличествоКолонок + 1));
						
					КонецЕсли;
					
				КонецЦикла;
				
			КонецЕсли;
			
		КонецЦикла;	// Конец цикла перебора строк 
		
	КонецЦикла;	// Конец цикла перебора колонок 
	
	// Переберем все элементы в массиве вычисленных ширин колонок
	Для ТекущаяКолонка = 0 По ШириныКолонок.ВГраница() Цикл
		
		Если ШириныКолонок[ТекущаяКолонка] <> Неопределено Тогда
			// Ширина колонок установлена
			// Установим ширину области ячеек
			ТабличныйДокумент.Область(НачальнаяСтрока, ТекущаяКолонка + 1,, ТекущаяКолонка + 1).ШиринаКолонки = ШириныКолонок[ТекущаяКолонка] + 1;
			
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

#КонецОбласти


