
////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ МЕХАНИЗМА РИБ

Процедура ДобавитьПрефиксУзла(Префикс) Экспорт
	
	Если ПараметрыСеанса.ИспользованиеРИБ Тогда
		Префикс = ПараметрыСеанса.ПрефиксУзлаРаспределеннойИнформационнойБазы + Префикс;
	КонецЕсли;
	
КонецПроцедуры

Процедура ОпределитьСозданиеПервогоУзлаПроизошловМонопольномРежиме(Отказ) Экспорт
	
	МассивСоединений = ПолучитьСоединенияИнформационнойБазы();
	НомерТекущегоСоединения = НомерСоединенияИнформационнойБазы();
	
	Для каждого Соединение ИЗ МассивСоединений Цикл
		
		Если Соединение.ИмяПриложения <> "Designer" 
			И Соединение.НомерСоединения <> НомерТекущегоСоединения Тогда
			
			СообщитьОбОшибке("Первоначальное создание узла плана обмена должно выполняться в монопольном режиме!");
			Отказ = Истина;
			Прервать;
			
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

Процедура СообщитьИнформацияОПрефиксации() Экспорт
	
	Сообщить("Для задействования механизма установки префиксов объектов необходимо установить константу ""Префикс узла для распределенной информационной базы"" 
	| и перезапустить текущий сеанс работы 1С:Предприятия.");
	Сообщить("Текущее значение префикса: " + ПараметрыСеанса.ПрефиксУзлаРаспределеннойИнформационнойБазы);
	
КонецПроцедуры


////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ УПРАВЛЕНИЯ НОМЕРАМИ ДОКУМЕНТОВ

Процедура ПриУстановкеНовогоНомераДокумента(Источник, СтандартнаяОбработка, Префикс) Экспорт
	
	ДобавитьПрефиксУзла(Префикс);	
	
Конецпроцедуры

Процедура ПриУстановкеНовогоКодаСправочника(Источник, СтандартнаяОбработка, Префикс) Экспорт
	
	ДобавитьПрефиксУзла(Префикс);
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////

Функция ШестнадцатиричноеВДесятичное(Источник) Экспорт
	
	Результат = 0;
	
	Для Поз = 1 По СтрДлина(Источник) Цикл
		ТекКод = КодСимвола(Источник, Поз);
		
		Если ТекКод >= КодСимвола("0") И ТекКод <= КодСимвола("9") Тогда
			ТекКод = ТекКод - КодСимвола("0");
		ИначеЕсли ТекКод >= КодСимвола("a") И ТекКод <= КодСимвола("f") Тогда
			ТекКод = ТекКод +10 - КодСимвола("a");
		ИначеЕсли ТекКод >= КодСимвола("A") И ТекКод <= КодСимвола("F") Тогда
			ТекКод = ТекКод +10 - КодСимвола("A");
		КонецЕсли;
		
		Результат = Результат * 16 + ТекКод;
		
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

Функция ДесятичноеВШестнадцатиричное(Источник) Экспорт
	
	ШеснадцатиричныеСимволы = "0123456789ABCDEF";
	
	Если Источник < 0 Тогда
		Возврат "00";
	КонецЕсли;
	Если Источник > 255 Тогда
		Возврат "FF";
	КонецЕсли;
	
	ПервыйСимвол	= Цел(Источник / 16) + 1;
	ВтройСимвол		= Источник % 16;
	
	Возврат Сред(ШеснадцатиричныеСимволы, ПервыйСимвол, 1) + Сред(ШеснадцатиричныеСимволы, ВтройСимвол, 1);
	
КонецФункции

Функция ЧетноеЧисло(Число) Экспорт
	
	Возврат Цел(Число/2) = Число/2;
	
КонецФункции

// Анализирует строку Стр на наличие в ней символов - не цифр.
// Возвращает Истина, если в строке присутствуют символы, не являющиеся цифрами.
// В противном случае возвращает Ложь.
//
Функция ЕстьНеЦифрыВСтроке(Стр) Экспорт
	
	КодСимвола0 = КодСимвола("0");
	КодСимвола9 = КодСимвола("9");
	
	Для Инд = 1 По СтрДлина(Стр) Цикл
		Если НЕ (КодСимвола(Стр, Инд) >= КодСимвола0 И КодСимвола(Стр, Инд) <= КодСимвола9) Тогда
			Возврат Истина;
		КонецЕсли;
	КонецЦикла;
	Возврат Ложь;
	
КонецФункции

// Функция проверяет наличие в строке только цифр
//
// Параметры
//  СтрокаПроверки - Строка для проверки только цифр
//
// Возвращаемое значение:
//   Булево
//
Функция ТолькоЦифрыВСтроке(Знач СтрокаПроверки, УчитыватьЛидирующиеНули = Истина, УчитыватьПробелы = Истина) Экспорт
	
	Если ТипЗнч(СтрокаПроверки) <> Тип("Строка") Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если НЕ ЗначениеЗаполнено(СтрокаПроверки) Тогда
		Возврат Истина;
	КонецЕсли; 
	
	Если НЕ УчитыватьПробелы Тогда
		СтрокаПроверки = СтрЗаменить(СтрокаПроверки, " ", "");
	КонецЕсли;
	
	Если НЕ УчитыватьЛидирующиеНули Тогда
		НомерПервойЦифры = 0;
		Для а = 1 По СтрДлина(СтрокаПроверки) Цикл
			НомерПервойЦифры = НомерПервойЦифры + 1;
			КодСимвола = КодСимвола(Сред(СтрокаПроверки, а, 1));
			Если КодСимвола <> 48 Тогда
				Прервать;
			КонецЕсли;
		КонецЦикла;
		СтрокаПроверки = Сред(СтрокаПроверки, НомерПервойЦифры);
	КонецЕсли;
	
	Для а = 1 По СтрДлина(СтрокаПроверки) Цикл
		КодСимвола = КодСимвола(Сред(СтрокаПроверки, а, 1));
		Если НЕ (КодСимвола >= 48 И КодСимвола <= 57) Тогда
			Возврат Ложь;
		КонецЕсли; 
	КонецЦикла; 
	
	Возврат Истина;
	
КонецФункции

// функция из исходной строки формирует строку для поиска данных в запросе
Функция СформироватьСтрокуДляПоискаВЗапросе(Знач СтрокаПоиска) Экспорт
	
	ИтоговаяСтрокаДляПоиска = СтрокаПоиска;
	ИтоговаяСтрокаДляПоиска = СтрЗаменить(ИтоговаяСтрокаДляПоиска, "~", "~~");
	ИтоговаяСтрокаДляПоиска = СтрЗаменить(ИтоговаяСтрокаДляПоиска, "%", "~%");
	ИтоговаяСтрокаДляПоиска = СтрЗаменить(ИтоговаяСтрокаДляПоиска, "_", "~_");
	ИтоговаяСтрокаДляПоиска = СтрЗаменить(ИтоговаяСтрокаДляПоиска, "[", "~[");
	ИтоговаяСтрокаДляПоиска = СтрЗаменить(ИтоговаяСтрокаДляПоиска, "-", "~-");
	
	Возврат ИтоговаяСтрокаДляПоиска;
	
КонецФункции

// Процедура переносит строку из запроса в Структуру
Процедура ПеренестиСтрокуВыборкиВСтруктуру(РезультатЗапроса, СтрокаВыборки, СтруктураЭлемента)
	
	Если СтруктураЭлемента = Неопределено 
		ИЛИ РезультатЗапроса = Неопределено 
		ИЛИ СтрокаВыборки = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	СтруктураЭлемента.Очистить();
	Для Каждого Колонка Из РезультатЗапроса.Колонки Цикл
		СтруктураЭлемента.Вставить(Колонка.Имя, СтрокаВыборки[Колонка.Имя]);
	КонецЦикла;
	
КонецПроцедуры

// Процедура переносит строку из таблицы в Структуру
Функция ПеренестиСтрокуТаблицыВСтруктуру(Таблица, СтрокаТаблицы, СтруктураЭлемента)Экспорт 
	
	Если СтруктураЭлемента = Неопределено Тогда
		СтруктураЭлемента = Новый Структура();
	Иначе	
		СтруктураЭлемента.Очистить();
	КонецЕсли; 
	
	Если 	СтрокаТаблицы 	= Неопределено 
		ИЛИ Таблица 		= Неопределено Тогда
		Возврат СтруктураЭлемента;
	КонецЕсли;
	
	Для Каждого Колонка Из Таблица.Колонки Цикл
		СтруктураЭлемента.Вставить(Колонка.Имя, СтрокаТаблицы[Колонка.Имя]);
	КонецЦикла;
	
	Возврат СтруктураЭлемента;
	
КонецФункции

// функция ищет элемент в массиве. Если находит - возвращает его индекс, иначе -1
Функция ВернутьИндексВМассиве(МассивДанные, Элемент) Экспорт 
	
	Если МассивДанные = Неопределено Тогда
		Возврат -1;
	КонецЕсли;
	
	Для ИндексЭлемента = 0 По МассивДанные.ВГраница() Цикл
		
		Если  (МассивДанные[ИндексЭлемента] = Элемент) Тогда
			Возврат ИндексЭлемента;
		КонецЕсли;	
		
	КонецЦикла;
	
	// не нашли элемент
	Возврат -1;
	
КонецФункции

// Процедура проверяет переданный параметр, если он пустой, 
// то заполняет его указанным значением.
//
// Параметры:
//  Параметр - параметр, значение которого проверяется и заполняется.
//  Значение - значение для заполнения пустого параметра.
//
Процедура ЗаполнитьПустоеЗначение(Параметр, Значение) Экспорт
	
	Если НЕ ЗначениеЗаполнено(Параметр) И Параметр <> Значение Тогда
		Параметр = Значение;
	КонецЕсли;
	
КонецПроцедуры

// Процедура проверяет переданный параметр, если он не соответствует значению, 
// то присваивает ему указанное значение.
//
// Параметры:
//  Параметр - параметр, значение которого проверяется и заполняется.
//  Значение - значение для заполнения пустого параметра.
//
Процедура УстановитьНовоеЗначение(Параметр, Значение) Экспорт
	
	Если Параметр <> Значение Тогда
		Параметр = Значение;
	КонецЕсли;
	
КонецПроцедуры

// Предназначена для получения имени элемента перечисления по значению.
//
// Параметры:
//	Элемент перечисления.
//
// Возвращаемое значение:
//	Строка - имя элемента перечисления в метаданных.
//
Функция ПолучитьИмяЭлементаПеречисленияПоЗначению(ЗначениеПеречисления) Экспорт
	
	ИмяЭлемента = Строка(ЗначениеПеречисления);
	Для каждого ЭлементПеречисления Из ЗначениеПеречисления.Метаданные().ЗначенияПеречисления Цикл
		Если ЭлементПеречисления.Синоним = Строка(ЗначениеПеречисления) Тогда
			ИмяЭлемента = ЭлементПеречисления.Имя;
			Прервать;
		КонецЕсли; 
	КонецЦикла;
	
	Возврат ИмяЭлемента;
	
КонецФункции // ПолучитьПериодичностьДляЗапросаПоЗначениюПеречисления()

// Предназначена для получения ссылки на элемент перечисления по его имени.
//
// Параметры:
//	Элемент перечисления.
//
// Возвращаемое значение:
//	Строка - имя элемента перечисления в метаданных.
//
Функция ПолучитьЗначениеПеречисленияПоИмени(ИмяОбъекта,ИмяПеречисления) Экспорт
	
	Если НЕ ЗначениеЗаполнено(ИмяПеречисления) Тогда
		
		Попытка
			Возврат Перечисления[ИмяОбъекта].ПустаяСсылка();
		Исключение
			Возврат Неопределено;
		КонецПопытки
		
	Иначе
		
		Если ТипЗнч(ИмяПеречисления)=Тип("Строка") Тогда
			
			Попытка
				Возврат Перечисления[ИмяОбъекта][ИмяПеречисления];
			Исключение
				Возврат Неопределено;
			КонецПопытки
			
		Иначе
			
			Возврат ИмяПеречисления;
			
		КонецЕсли;
		
	КонецЕсли;
		
КонецФункции // ПолучитьПериодичностьДляЗапросаПоЗначениюПеречисления()

Функция ВИБ_ПолучитьЗначениеПеречисленияПоИмени(ТекСоединениеВИБ,ИмяОбъекта,ИмяПеречисления)
	
	Если НЕ ЗначениеЗаполнено(ИмяПеречисления) Тогда
		
		Попытка
			Возврат ТекСоединениеВИБ.Перечисления[ИмяОбъекта].ПустаяСсылка();
		Исключение
			Возврат Неопределено;
		КонецПопытки
		
	Иначе
		
		Попытка
			Возврат ТекСоединениеВИБ.Перечисления[ИмяОбъекта][ИмяПеречисления];
		Исключение
			Возврат Неопределено;
		КонецПопытки
		
	КонецЕсли;
		
КонецФункции // ВИБ_ПолучитьЗначениеПеречисленияПоИмени() 

// Формирует строку заданной длины, дополняя
// переданную строку пробелами.
// Параметры:
//	НачСтрока - исходная строка
//  ЗаданнаяДлина - необходимая длина строки
//
Функция ДополнитьДоЗаданнойДлины(НачСтрока,ЗаданнаяДлина) Экспорт
	
	ЧислоПробелов=ЗаданнаяДлина-СтрДлина(НачСтрока);
	ТекущаяСтрока=НачСтрока;
	
	Если ЧислоПробелов<0 Тогда
		Возврат Лев(НачСтрока,ЗаданнаяДлина);
	Иначе
		
		Для Индекс=1 По ЧислоПробелов Цикл
			
			ТекущаяСтрока=ТекущаяСтрока+" ";
			
		КонецЦикла;
		
		Возврат ТекущаяСтрока;
		
	КонецЕсли;
	
КонецФункции // ДополнитьДоЗаданнойДлины()

// Получаем из полного номера версии конфигурации номер релиза без номера сборки.
//
// Параметры
//  НомерВерсии  – Строка – полный номер версии
//  Развернуто  – Соответствие, содержит номер Редакции, Подредакции, Версии, Сборки
//
// Возвращаемое значение:
//  Строка – номер релиза без номера сборки
//
Функция ПолучитьНомерРелиза(НомерВерсии, Развернуто = "") Экспорт
	
	МассивИндексов=РазложитьСтрокуВМассивПодстрок(НомерВерсии,".");
	
	Развернуто=Новый Структура;
	
	Если МассивИндексов.Количество()=4 Тогда
		
		Развернуто.Вставить("Редакция",		Число(МассивИндексов[0]));
		Развернуто.Вставить("Подредакция",	Число(МассивИндексов[1]));
		Развернуто.Вставить("Версия",		Число(МассивИндексов[2]));
		Развернуто.Вставить("Сборка",		Число(МассивИндексов[3]));
		
	Иначе
		
		Развернуто.Вставить("Редакция",		0);
		Развернуто.Вставить("Подредакция",	0);
		Развернуто.Вставить("Версия",		0);
		Развернуто.Вставить("Сборка",		0);
		
	КонецЕсли;
	
	Возврат Развернуто;
	
КонецФункции // ПолучитьНомерРелиза()

//Функция добавляет "ЧислоДней" к "Дата"
//
Функция ДобавитьДень(Дата, ЧислоДней) Экспорт
	
	Возврат Дата + ЧислоДней * 86400; // 86400 = 24*60*60 - число секунд в дне;
	
КонецФункции // () 

// Функция возвращает разность в днях между "Дата1" и "Дата2"
//
Функция РазностьДатВДнях(Знач Дата1, Знач Дата2) Экспорт
	Дата1 = ?(ЗначениеЗаполнено(Дата1), Дата1, ПустоеЗначениеТипа(Тип("Дата")));
	Дата2 = ?(ЗначениеЗаполнено(Дата2), Дата2, ПустоеЗначениеТипа(Тип("Дата")));
	Возврат Окр((Дата1 - Дата2) / 86400, 2); // 86400 = 24*60*60 - число секунд в дне;
	
КонецФункции // () 

// Возвращает количество периодов между указанными датами
//
// Параметры
//  ДатаНачала, ДатаКонца: Дата  – границы интервала
//  Периодичность (Перечисления.Периодичность): периодичность планирования
//
// Возвращаемое значение:
//   КоличествоПериодов   – количество периодов в переданном интервале
//
Функция РассчитатьКоличествоПериодов(ДатаНачала,ДатаКонца,Периодичность) Экспорт
	
	Если ДатаНачала<ДатаКонца Тогда
		
		ИсходнаяДата=ДатаНачала;
		КонечнаяДата=ДатаКонца;
		Коэффициент=1;
		
	ИначеЕсли  ДатаНачала>ДатаКонца Тогда
		
		ИсходнаяДата=ДатаКонца;
		КонечнаяДата=ДатаНачала;
		Коэффициент=-1;
		
	ИначеЕсли ДатаНачала=ДатаКонца Тогда
		
		Возврат 0;
		
	КонецЕсли;
	
	ТекущаяДата=ДобавитьИнтервал(ИсходнаяДата,Периодичность,1);
	
	Если КонецДня(ТекущаяДата)>КонецДня(КонечнаяДата) Тогда
		Возврат 0;
	КонецЕсли;
	
	КоличествоПериодов=1;
	
	Пока ДатаКонцаПериода(ТекущаяДата,Периодичность)<КонецДня(КонечнаяДата) Цикл
		
		КоличествоПериодов=КоличествоПериодов+1;
		
		ТекущаяДата=ДобавитьИнтервал(ТекущаяДата,Периодичность,1);
		
	КонецЦикла;
	
	Возврат КоличествоПериодов*Коэффициент;
	
КонецФункции // РассчитатьКоличествоПериодов()

Функция НачалоДекады(ДатаНачала) Экспорт
	
	Если День(ДатаНачала) < 10 Тогда
		Возврат НачалоМесяца(ДатаНачала);
	ИначеЕсли День(ДатаНачала) < 20 Тогда
		Возврат ДобавитьДень(НачалоМесяца(ДатаНачала), 10);
	Иначе 
		Возврат ДобавитьДень(НачалоМесяца(ДатаНачала), 20);
	КонецЕсли;
	
КонецФункции // НачалоДекады()

Функция КонецДекады(ДатаНачала) Экспорт
	
	Если День(ДатаНачала) < 10 Тогда
		Возврат ДобавитьДень(ДатаНачала, 10) - 1;
	ИначеЕсли День(ДатаНачала) < 20 Тогда
		Возврат ДобавитьДень(ДатаНачала, 10) - 1;
	Иначе 
		Возврат КонецМесяца(ДатаНачала);
	КонецЕсли;
	
КонецФункции // КонецДекады() 

Функция НачалоНеделиПоМесяцу(ДатаНачала) Экспорт
	
	Если День(ДатаНачала) < 7 Тогда
		Возврат ?(День(НачалоНедели(ДатаНачала))>День(ДатаНачала),НачалоМесяца(ДатаНачала),НачалоНедели(ДатаНачала));
	Иначе
		Возврат НачалоНедели(ДатаНачала);
	КонецЕсли;
	
КонецФункции // НачалоНеделиПоМесяцу

Функция КонецНеделиПоМесяцу(ДатаНачала) Экспорт
	
	Возврат ?(День(ДатаНачала)<День(КонецНедели(ДатаНачала)),КонецНедели(ДатаНачала),КонецМесяца(ДатаНачала));	
	
КонецФункции // КонецНеделиПоМесяцу() 

// Функция добавляет интервал к дате
//
// Параметры:
//	Периодичность (Перечисления.Периодичность)	- пнриодичность планирования по сценарию.
//	ДатаВПериоде (Дата)							- произвольная дата
//	Смещение (число)							- определяет направление и количество периодов, в котором сдвигается дата
//
// Возвращаемое значение:
//	Дата, отстоящая от исходной на заданное количество периодов 
//
Функция ДобавитьИнтервал(ДатаПериода,Периодичность,Смещение) Экспорт
	
	Если Смещение = 0 Тогда
		НоваяДатаПериода = ДатаПериода;
		
	ИначеЕсли Периодичность = Перечисления.Периодичность.День Тогда
		НоваяДатаПериода = НачалоДня(ДатаПериода + Смещение*24*3600);
		
	ИначеЕсли Периодичность = Перечисления.Периодичность.Неделя Тогда
		НоваяДатаПериода = НачалоНеделиПоМесяцу(ДатаПериода + Смещение*7*24*3600);
		
	ИначеЕсли Периодичность = Перечисления.Периодичность.Декада Тогда
		НоваяДатаПериода = НачалоДекады(ДатаПериода + Смещение*11*24*3600);
		
	ИначеЕсли Периодичность = Перечисления.Периодичность.Месяц Тогда
		НоваяДатаПериода = ДобавитьМесяц(ДатаПериода, Смещение);
		
	ИначеЕсли Периодичность = Перечисления.Периодичность.Квартал Тогда
		НоваяДатаПериода = ДобавитьМесяц(ДатаПериода, Смещение*3);
		
	ИначеЕсли Периодичность = Перечисления.Периодичность.Год Тогда
		НоваяДатаПериода = ДобавитьМесяц(ДатаПериода, Смещение*12);
		
	Иначе
		НоваяДатаПериода=НачалоДня(ДатаПериода) + Смещение*24*3600;
		
	КонецЕсли;
	
	Возврат НоваяДатаПериода;
	
КонецФункции // ДобавитьИнтервал()

// Функция возвращает ближайшую дату начала периода планирования
//
// Параметры
//	Периодичность (Перечисления.Периодичность)	- периодичность планирования по сценарию.
//	ДатаВПериоде (Дата)							- произвольная дата
//
// Возвращаемое значение:
//	ДатаНачалаПериода		– ближайшая дата начала периода планирования
//
Функция ДатаНачалаПериода(ДатаВПериоде,Периодичность) Экспорт
	
	Если НЕ ТипЗнч(ДатаВПериоде)=Тип("Дата") Тогда
		Возврат '00010101';
	КонецЕсли;
	
	Если Периодичность=Перечисления.Периодичность.День Тогда
		Возврат НачалоДня(ДатаВПериоде);
	ИначеЕсли Периодичность=Перечисления.Периодичность.Неделя Тогда
		Возврат НачалоНеделиПоМесяцу(ДатаВПериоде);
	ИначеЕсли Периодичность=Перечисления.Периодичность.Декада Тогда
		Возврат НачалоДекады(ДатаВПериоде);
	ИначеЕсли Периодичность=Перечисления.Периодичность.Месяц Тогда
		Возврат НачалоМесяца (ДатаВПериоде);
	ИначеЕсли Периодичность=Перечисления.Периодичность.Квартал Тогда
		Возврат НачалоКвартала (ДатаВПериоде);
	ИначеЕсли Периодичность=Перечисления.Периодичность.Год Тогда
		Возврат НачалоГода (ДатаВПериоде);
	Иначе
		Возврат НачалоДня(ДатаВПериоде);
	КонецЕсли;
	
КонецФункции // ДатаНачалаПериода()

// Функция возвращает ближайшую дату окончания периода планирования
//
// Параметры
//	Периодичность (Перечисления.Периодичность)	- периодичность планирования по сценарию.
//	ДатаВПериоде (Дата)							- произвольная дата
//
// Возвращаемое значение:
//	ДатаКонцаПериода	– ближайшая дата окончания периода планирования
//
Функция ДатаКонцаПериода(ДатаВПериоде,Периодичность) Экспорт
	
	Если Периодичность=Перечисления.Периодичность.День Тогда
		Возврат КонецДня(ДатаВПериоде);
	ИначеЕсли Периодичность=Перечисления.Периодичность.Неделя Тогда
		Возврат КонецНедели (ДатаВПериоде);
	ИначеЕсли Периодичность=Перечисления.Периодичность.Месяц Тогда
		Возврат КонецМесяца (ДатаВПериоде);
	ИначеЕсли Периодичность=Перечисления.Периодичность.Квартал Тогда
		Возврат КонецКвартала (ДатаВПериоде);
	ИначеЕсли Периодичность=Перечисления.Периодичность.Год Тогда
		Возврат КонецГода (ДатаВПериоде);
	Иначе
		Возврат КонецДня(ДатаВПериоде);
	КонецЕсли;
	
КонецФункции // ДатаКонцаПериода()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С ТИПАМИ

// Предназначена для получения пустого значения заданного типа:
//	примитивного, или ссылочного. Используется
//
// Параметры:
//	ЗаданныйТип   - тип, пустое значение которого нужно получить
//
Функция ПустоеЗначениеТипа(ЗаданныйТип) Экспорт
	
	Если ЗаданныйТип = Тип("Число") Тогда
		Возврат 0;
	ИначеЕсли ЗаданныйТип = Тип("Строка") Тогда
		Возврат "";
	ИначеЕсли ЗаданныйТип = Тип("Дата") Тогда
		Возврат '00010101000000';
	ИначеЕсли ЗаданныйТип = Тип("Булево") Тогда
		Возврат Ложь;
	Иначе
		Возврат Новый (ЗаданныйТип);
	КонецЕсли;
	
КонецФункции // ПустоеЗначениеТипа();

// Служебная функция, предназначенная для получения описания типов строки, заданной длины.
// 
// Параметры:
//  ДлинаСтроки - число, длина строки.
//
// Возвращаемое значение:
//  Объект "ОписаниеТипов" для строки указанной длины.
//
Функция ПолучитьОписаниеТиповСтроки(ДлинаСтроки) Экспорт
	
	Массив = Новый Массив; 
	Массив.Добавить(Тип("Строка"));
	КвалификаторСтроки = Новый КвалификаторыСтроки(ДлинаСтроки, ДопустимаяДлина.Переменная);
	Возврат Новый ОписаниеТипов(Массив, , КвалификаторСтроки);
	
КонецФункции // ПолучитьОписаниеТиповСтроки()	 

// Служебная функция, предназначенная для получения описания типов числа, заданной разрядности.
// 
// Параметры:
//  Разрядность 			- число, разряд числа.
//  РазрядностьДробнойЧасти - число, разряд дробной части.
//
// Возвращаемое значение:
//  Объект "ОписаниеТипов" для числа указанной разрядности.
//
Функция ПолучитьОписаниеТиповЧисла(Разрядность,РазрядностьДробнойЧасти=0) Экспорт
	
	Массив = Новый Массив;
	Массив.Добавить(Тип("Число"));
	КвалификаторЧисла = Новый КвалификаторыЧисла(Разрядность,РазрядностьДробнойЧасти);
	Возврат Новый ОписаниеТипов(Массив, КвалификаторЧисла);
	
КонецФункции	// ПолучитьОписаниеТиповЧисла()

// Служебная функция, предназначенная для получения описания типов ссылочного значения
// по переданному строковому описанию
// 
// Параметры:
//  ТекстОписание 			- строка
// Возвращаемое значение:
//  Объект "ОписаниеТипов" описанного ссылочного объекта метаданных.
//
Функция ПолучитьОписаниеТиповСсылка(ТекстОписание) Экспорт
	
	Массив = Новый Массив;
	Массив.Добавить(Тип(ТекстОписание));
	Возврат Новый ОписаниеТипов(Массив);
	
КонецФункции	// ПолучитьОписаниеТиповЧисла()

// Служебная функция, предназначенная для получения описания типов булево.
//
// Возвращаемое значение:
//  Объект "ОписаниеТипов" булева типа.
//
Функция ПолучитьОписаниеТиповБулево() Экспорт
	
	Массив = Новый Массив;
	Массив.Добавить(Тип("Булево"));
	Возврат Новый ОписаниеТипов(Массив);
	
КонецФункции // ПолучитьОписаниеТиповБулево() 

// Служебная функция, предназначенная для получения описания типов таблица значений.
//
// Возвращаемое значение:
//  Объект "ОписаниеТипов" булева типа.
//
Функция ПолучитьОписаниеТиповТЗ() Экспорт
	
	Массив = Новый Массив;
	Массив.Добавить(Тип("ТаблицаЗначений"));
	Возврат Новый ОписаниеТипов(Массив);
	
КонецФункции // ПолучитьОписаниеТиповБулево()

// Служебная функция, предназначенная для получения описания типов список значений.
//
// Возвращаемое значение:
//  Объект "ОписаниеТипов" булева типа.
//
Функция ПолучитьОписаниеТиповСписокЗначений() Экспорт
	
	Массив = Новый Массив;
	Массив.Добавить(Тип("СписокЗначений"));
	Возврат Новый ОписаниеТипов(Массив);
	
КонецФункции // ПолучитьОписаниеТиповБулево()

// Служебная функция, предназначенная для получения описания типов структура.
//
// Возвращаемое значение:
//  Объект "ОписаниеТипов" типа Структура
//
Функция ПолучитьОписаниеТиповСтруктура() Экспорт
	
	Массив = Новый Массив;
	Массив.Добавить(Тип("Структура"));
	Возврат Новый ОписаниеТипов(Массив);
	
КонецФункции // ПолучитьОписаниеТиповСтруктура()

// Служебная функция, предназначенная для получения описания типов даты
// 
// Параметры:
//  ЧастиДаты - системное перечисление ЧастиДаты.
// 
Функция ПолучитьОписаниеТиповДаты(ЧастиДаты) Экспорт
	
	Массив = Новый Массив;
	Массив.Добавить(Тип("Дата"));
	КвалификаторДаты = Новый КвалификаторыДаты(ЧастиДаты);
	Возврат Новый ОписаниеТипов(Массив, , , КвалификаторДаты);
	
КонецФункции	// ПолучитьОписаниеТиповДаты()

// Служебная функция, определяющая примитивность переданного типа
//
Функция ПримитивныйТип(Тип) Экспорт
	
	Возврат (Тип = Тип("Строка") ИЛИ Тип = Тип("Дата") ИЛИ Тип = Тип("Булево") ИЛИ Тип = Тип("Число"));	
	
КонецФункции

// Служебная функция, определяющая примитивность переданного типа
//
Функция ПримитивныйТипСтрока(СтрокаТип) Экспорт
	
	Возврат (СтрокаТип = "Строка" ИЛИ СтрокаТип = "Дата" ИЛИ СтрокаТип = "Булево" ИЛИ СтрокаТип = "Число");	
	
КонецФункции

Функция ПолучитьДанныеТипа(СтрокаТип) Экспорт
	
	МассивСтрок=РазложитьСтрокуВМассивПодстрок(СтрокаТип,".");
	
	СтруктураТипа=Новый Структура;
	
	Если МассивСтрок.Количество()=2 Тогда 
		
		СтруктураТипа.Вставить("ТипМетаДанных",МассивСтрок[0]);
		СтруктураТипа.Вставить("СправочникВИБ",МассивСтрок[1]);
		
	Иначе
		
		СтруктураТипа.Вставить("ТипМетаДанных");
		СтруктураТипа.Вставить("СправочникВИБ");
		
	КонецЕсли;
	
	Возврат СтруктураТипа;
	
КонецФункции // ПолучитьДанныеТипа()

Функция ПреобразоватьТипИзСтроки(Тип,ВозвращатьТип=Истина) Экспорт
	
	Если Тип="Строка" Тогда
		
		Возврат ?(ВозвращатьТип,Тип("Строка"),"Строка");
		
	ИначеЕсли Тип="Число" Тогда
		
		Возврат ?(ВозвращатьТип,Тип("Число"),"Число");
		
	ИначеЕсли Тип="Дата" Тогда
		
		Возврат ?(ВозвращатьТип,Тип("Дата"),"Дата");
		
	ИначеЕсли Тип="Булево" Тогда
		
		Возврат ?(ВозвращатьТип,Тип("Булево"),"Булево");
		
	Иначе
		
		Возврат Неопределено;
		
	КонецЕсли;
	
КонецФункции // ПреобразоватьТИПизВИБ()

Функция ПолучитьСписокИзТипа(ИсходныйТип) Экспорт
	
	СписокТипов=Новый СписокЗначений;
	
	Если ТипЗнч(ИсходныйТип)=Тип("Строка") Тогда
		
		РабочийТип=Тип(ИсходныйТип);
		СписокТипов.Добавить(РабочийТип);
		
	Иначе
		
		СписокТипов.Добавить(ИсходныйТип);
		
	КонецЕсли;
	
	Возврат СписокТипов;
	
КонецФункции // ПолучитьСписокИзТипа() 

Функция ПолучитьНаименованиеСсылочногоТипа(Тип) Экспорт
	
	Если ТипЗнч(Тип)=Тип("Строка") Тогда // Передано полное имя объекта метаданных
		
		Если Найти(Тип,"Справочник")>0 Тогда
			Возврат "Справочник";
		ИначеЕсли Найти(Тип,"Перечисление")>0 Тогда
			Возврат "Перечисление";
		ИначеЕсли Найти(Тип,"Документ")>0 Тогда
			Возврат "Документ";
		Иначе
			Возврат "НеПоддерживается";
		КонецЕсли;
		
	Иначе // Передан тип в виде COM - объекта	
		
		Попытка
			Если Справочники.ТипВсеСсылки().СодержитТип(Тип) Тогда
				Возврат "Справочник";
			ИначеЕсли Перечисления.ТипВсеСсылки().СодержитТип(Тип) Тогда
				Возврат "Перечисление";
			ИначеЕсли Документы.ТипВсеСсылки().СодержитТип(Тип) Тогда
				Возврат "Документ";
			Иначе
				Возврат "НеПоддерживается";
			КонецЕсли;
		Исключение
			Возврат "НеПоддерживается";
		КонецПопытки;
		
	КонецЕсли;
	
КонецФункции

Процедура ОпределитьГраницыИнтервала(ДатаНачала,ДатаОкончания,Периодичность) Экспорт
	
	Если (Не ЗначениеЗаполнено(Периодичность)) 
		ИЛИ (Не (ЗначениеЗаполнено(ДатаНачала) ИЛИ ЗначениеЗаполнено(ДатаОкончания))) Тогда
		
		Возврат;
		
	КонецЕсли;
	
	Если ((НЕ ЗначениеЗаполнено(ДатаОкончания)) ИЛИ ДатаОкончания<ДатаНачала) Тогда
		
		ДатаОкончания=ДатаКонцаПериода(ДатаНачала,Периодичность);
		
	ИначеЕсли ((НЕ ЗначениеЗаполнено(ДатаНачала)) ИЛИ ДатаНачала>ДатаОкончания) Тогда
		
		ДатаНачала=ДатаНачалаПериода(ДатаОкончания,Периодичность);
		
	Иначе
		
		ДатаНачала=ДатаНачалаПериода(ДатаНачала,Периодичность);
		ДатаОкончания=ДатаКонцаПериода(ДатаНачала,Периодичность);
		
	КонецЕсли;
	
КонецПроцедуры // ОпределитьГраницыИнтервала()

// формирует список значений, описывающий государственные праздники РФ
//
// Параметры
//  КалендарныйГод - число - год, за который возвращается список праздников
//
// Возвращаемое значение:
//   список значений, содержащий строки-месяцедни праздников
//
Функция ПолучитьСписокПраздниковРФ(КалендарныйГод) Экспорт
	
	СписокПраздников = Новый СписокЗначений();
	Если КалендарныйГод < 2005 Тогда
		СписокПраздников.Добавить("0101", "Новый Год");
		СписокПраздников.Добавить("0102", "Новый Год");
		СписокПраздников.Добавить("0107", "Рождество Христово");
		СписокПраздников.Добавить("0223", "День защитника Отечества");
		СписокПраздников.Добавить("0308", "Международный женский день");
		СписокПраздников.Добавить("0501", "Праздник Весны и Труда");
		СписокПраздников.Добавить("0502", "Праздник Весны и Труда");
		СписокПраздников.Добавить("0509", "День Победы");
		СписокПраздников.Добавить("0612", "День России");
		СписокПраздников.Добавить("1107", "День согласия и примирения");
		СписокПраздников.Добавить("1212", "День Конституции РФ");
	Иначе  // Федеральный закон №201-ФЗ от 29 декабря 2004 года
		СписокПраздников.Добавить("0101", "Новогодние каникулы");
		СписокПраздников.Добавить("0102", "Новогодние каникулы");
		СписокПраздников.Добавить("0103", "Новогодние каникулы");
		СписокПраздников.Добавить("0104", "Новогодние каникулы");
		СписокПраздников.Добавить("0105", "Новогодние каникулы");
		СписокПраздников.Добавить("0107", "Рождество Христово");
		СписокПраздников.Добавить("0223", "День защитника Отечества");
		СписокПраздников.Добавить("0308", "Международный женский день");
		СписокПраздников.Добавить("0501", "Праздник Весны и Труда");
		СписокПраздников.Добавить("0509", "День Победы");
		СписокПраздников.Добавить("0612", "День России");
		СписокПраздников.Добавить("1104", "День народного единства");
	КонецЕсли;
	
	Возврат СписокПраздников
	
КонецФункции // ПолучитьСписокПраздниковРФ()

// Функция возвращает число рабочих дней между заданными датами по регламентированному производственному календарю
//
//Параметры:
// ДатаНач      - начальная дата
// ДатаКон      - конечная дата
//
Функция ЧислоРабочихДней(ДатаНач, ДатаКон) Экспорт
	
	Запрос = Новый  Запрос;
	
	Если ДатаНач>ДатаКон Тогда
		
		Коэффициент=-1;	
		Запрос.УстановитьПараметр("ДатаНач",             ДатаКон);
		Запрос.УстановитьПараметр("ДатаКон",             ДатаНач);
		
	Иначе
		
		Коэффициент=1;
		Запрос.УстановитьПараметр("ДатаНач",             ДатаНач);
		Запрос.УстановитьПараметр("ДатаКон",             ДатаКон);
		
	КонецЕсли;
	
	Запрос.УстановитьПараметр("РабочийДень",         Перечисления.ВидыДнейПроизводственногоКалендаря.Рабочий);
	Запрос.УстановитьПараметр("ПредпраздничныйДень", Перечисления.ВидыДнейПроизводственногоКалендаря.Предпраздничный);
	
	Запрос.Текст = "
	|ВЫБРАТЬ
	|	ЕстьNull(СУММА(ВЫБОР
	|			КОГДА РегламентированныйПроизводственныйКалендарь.ВидДня = &РабочийДень
	|				ИЛИ РегламентированныйПроизводственныйКалендарь.ВидДня = &ПредпраздничныйДень
	|				ТОГДА 1
	|			ИНАЧЕ 0
	|		КОНЕЦ),0) КАК ЧислоРабочихДней
	|ИЗ
	|	РегистрСведений.РегламентированныйПроизводственныйКалендарь КАК РегламентированныйПроизводственныйКалендарь
	|ГДЕ
	|	РегламентированныйПроизводственныйКалендарь.ДатаКалендаря МЕЖДУ &ДатаНач И &ДатаКон
	|	//РегламентированныйПроизводственныйКалендарь.Год = &Год";
	
	Выборка = Запрос.Выполнить().Выбрать();
	
	Если Выборка.Следующий() Тогда
		Возврат (Выборка.ЧислоРабочихДней-1)*Коэффициент;
	КонецЕсли;
	
	Возврат 0;
	
КонецФункции

// Функция возвращает дату отстоящую на заданное количество рабочих дней от начальной в соответствии с
//регламентированным производственным календарем
//
//Параметры:
// ДатаНач      - начальная дата
// ЧислоДней    - количество рабочих дней, на которое искомая дата должна отстоять от начальной
//
Функция ОпределитьРабочуюДату(ДатаНач, ЧислоДней) Экспорт
	
	Запрос = Новый  Запрос;
	Запрос.УстановитьПараметр("ДатаНач",             ДатаНач);
	Запрос.УстановитьПараметр("ЧислоДней",           ЧислоДней);
	Запрос.УстановитьПараметр("РабочийДень",         Перечисления.ВидыДнейПроизводственногоКалендаря.Рабочий);
	Запрос.УстановитьПараметр("ПредпраздничныйДень", Перечисления.ВидыДнейПроизводственногоКалендаря.Предпраздничный);
	
	Если ЧислоДней > 0 Тогда
		Запрос.Текст = "
		|ВЫБРАТЬ РАЗРЕШЕННЫЕ ПЕРВЫЕ " + ЧислоДней + "
		|	РегламентированныйПроизводственныйКалендарь.ДатаКалендаря
		|ИЗ
		|	РегистрСведений.РегламентированныйПроизводственныйКалендарь КАК РегламентированныйПроизводственныйКалендарь
		|ГДЕ РегламентированныйПроизводственныйКалендарь.ДатаКалендаря > &ДатаНач
		|	 И (РегламентированныйПроизводственныйКалендарь.ВидДня = &РабочийДень
		|      ИЛИ РегламентированныйПроизводственныйКалендарь.ВидДня = &ПредпраздничныйДень)
		|УПОРЯДОЧИТЬ ПО
		|	ДатаКалендаря
		|";
		
	ИначеЕсли ЧислоДней=0 Тогда // Определяем первый рабочий день; если исходная дата - рабочий день, возвращаем его
		
		Запрос.Текст = "
		|ВЫБРАТЬ РАЗРЕШЕННЫЕ ПЕРВЫЕ 1
		|	РегламентированныйПроизводственныйКалендарь.ДатаКалендаря
		|ИЗ
		|	РегистрСведений.РегламентированныйПроизводственныйКалендарь КАК РегламентированныйПроизводственныйКалендарь
		|ГДЕ РегламентированныйПроизводственныйКалендарь.ДатаКалендаря >= &ДатаНач
		|	 И (РегламентированныйПроизводственныйКалендарь.ВидДня = &РабочийДень
		|      ИЛИ РегламентированныйПроизводственныйКалендарь.ВидДня = &ПредпраздничныйДень)
		|УПОРЯДОЧИТЬ ПО
		|	ДатаКалендаря
		|";
		
	Иначе
		
		ЧислоДней = -ЧислоДней;
		
		Запрос.Текст = "
		|ВЫБРАТЬ РАЗРЕШЕННЫЕ ПЕРВЫЕ " + ЧислоДней + "
		|	РегламентированныйПроизводственныйКалендарь.ДатаКалендаря
		|ИЗ
		|	РегистрСведений.РегламентированныйПроизводственныйКалендарь КАК РегламентированныйПроизводственныйКалендарь
		|ГДЕ РегламентированныйПроизводственныйКалендарь.ДатаКалендаря < &ДатаНач
		|	 И (РегламентированныйПроизводственныйКалендарь.ВидДня = &РабочийДень
		|      ИЛИ РегламентированныйПроизводственныйКалендарь.ВидДня = &ПредпраздничныйДень)
		|УПОРЯДОЧИТЬ ПО
		|	ДатаКалендаря УБЫВ
		|";
		
	КонецЕсли;
	
	Выборка = Запрос.Выполнить().Выбрать();
	
	Если Выборка.Количество()>0 Тогда
		Пока Выборка.Следующий() Цикл
			ТекДата = Выборка.ДатаКалендаря;
		КонецЦикла;
		Возврат ТекДата;
	КонецЕсли;
	
	Возврат ДатаНач;
	
КонецФункции

Функция ПолучитьМассивРабочихДней(ДатаНачала,ДатаОкончания) Экспорт;
	
	Запрос=Новый Запрос;
	Запрос.Текст = "ВЫБРАТЬ РАЗРЕШЕННЫЕ
	|	РегламентированныйПроизводственныйКалендарь.ДатаКалендаря КАК ДатаКалендаря
	|ИЗ
	|	РегистрСведений.РегламентированныйПроизводственныйКалендарь КАК РегламентированныйПроизводственныйКалендарь
	|ГДЕ
	|	РегламентированныйПроизводственныйКалендарь.ДатаКалендаря МЕЖДУ &ДатаНачала И &ДатаОкончания
	|	И (РегламентированныйПроизводственныйКалендарь.ВидДня = &РабочийДень
	|			ИЛИ РегламентированныйПроизводственныйКалендарь.ВидДня = &ПредпраздничныйДень)
	|
	|УПОРЯДОЧИТЬ ПО
	|	ДатаКалендаря";
	
	Запрос.УстановитьПараметр("РабочийДень",         Перечисления.ВидыДнейПроизводственногоКалендаря.Рабочий);
	Запрос.УстановитьПараметр("ПредпраздничныйДень", Перечисления.ВидыДнейПроизводственногоКалендаря.Предпраздничный);
	Запрос.УстановитьПараметр("ДатаНачала",ДатаНачала);
	Запрос.УстановитьПараметр("ДатаОкончания",ДатаОкончания);
	
	Возврат Запрос.Выполнить().Выгрузить().ВыгрузитьКолонку("ДатаКалендаря");	
	
КонецФункции // ПолучитьМассивРабочихДней() 

Функция ОпределитьСписокПодчиненныхПериодов(Периодичность,СписокПериодов=Неопределено) Экспорт
	
	Если СписокПериодов=Неопределено Тогда
		СписокПериодов=Новый СписокЗначений;
	КонецЕсли;
	
	Если Периодичность=Перечисления.Периодичность.Год Тогда
		
		СписокПериодов.Добавить(Перечисления.Периодичность.Полугодие);
		ОпределитьСписокПодчиненныхПериодов(Перечисления.Периодичность.Полугодие,СписокПериодов);
		
	ИначеЕсли Периодичность=Перечисления.Периодичность.Полугодие Тогда
		
		СписокПериодов.Добавить(Перечисления.Периодичность.Квартал);
		ОпределитьСписокПодчиненныхПериодов(Перечисления.Периодичность.Квартал,СписокПериодов);
		
	ИначеЕсли Периодичность=Перечисления.Периодичность.Квартал Тогда
		
		СписокПериодов.Добавить(Перечисления.Периодичность.Месяц);
		ОпределитьСписокПодчиненныхПериодов(Перечисления.Периодичность.Месяц,СписокПериодов);
		
	ИначеЕсли Периодичность=Перечисления.Периодичность.Месяц Тогда
		
		СписокПериодов.Добавить(Перечисления.Периодичность.Неделя);
		СписокПериодов.Добавить(Перечисления.Периодичность.Декада);
		СписокПериодов.Добавить(Перечисления.Периодичность.День);
		
	ИначеЕсли Периодичность=Перечисления.Периодичность.Неделя 
		ИЛИ Периодичность=Перечисления.Периодичность.Декада
		ИЛИ Периодичность=Перечисления.Периодичность.День Тогда
		
		СписокПериодов.Добавить(Перечисления.Периодичность.День);
		
	КонецЕсли;
	
	Возврат СписокПериодов;
	
КонецФункции // ОпределитьСписокПодчиненныхПериодов

Функция ОпределитьМассивВышестоящихПериодов(Периодичность,МассивПериодов=Неопределено) Экспорт
	
	Если МассивПериодов=Неопределено Тогда
		МассивПериодов=Новый Массив;
	КонецЕсли;
	
	Если Периодичность=Перечисления.Периодичность.День Тогда
		
		МассивПериодов.Добавить(Перечисления.Периодичность.Декада);
		МассивПериодов.Добавить(Перечисления.Периодичность.Неделя);
		ОпределитьМассивВышестоящихПериодов(Перечисления.Периодичность.Неделя,МассивПериодов);
		
	ИначеЕсли (Периодичность=Перечисления.Периодичность.Неделя ИЛИ Периодичность=Перечисления.Периодичность.Декада) Тогда
		
		МассивПериодов.Добавить(Перечисления.Периодичность.Месяц);
		ОпределитьМассивВышестоящихПериодов(Перечисления.Периодичность.Месяц,МассивПериодов);
		
	ИначеЕсли Периодичность=Перечисления.Периодичность.Месяц Тогда
		
		МассивПериодов.Добавить(Перечисления.Периодичность.Квартал);
		ОпределитьМассивВышестоящихПериодов(Перечисления.Периодичность.Квартал,МассивПериодов);
		
	ИначеЕсли Периодичность=Перечисления.Периодичность.Квартал Тогда
		
		МассивПериодов.Добавить(Перечисления.Периодичность.Полугодие);
		ОпределитьМассивВышестоящихПериодов(Перечисления.Периодичность.Полугодие,МассивПериодов);
		
	ИначеЕсли (Периодичность=Перечисления.Периодичность.Полугодие ИЛИ Периодичность=Перечисления.Периодичность.Год)  Тогда
		
		МассивПериодов.Добавить(Перечисления.Периодичность.Год);
		
	КонецЕсли;
	
	Возврат МассивПериодов;
	
КонецФункции // ОпределитьСписокВышестоящихПериодов()

Функция ТекстНачалаКонцаПериода(Периодичность,ДатаВПериоде=Неопределено) Экспорт
	
	ТекстПериод="";
	
	СтруктураТекст=Новый Структура;
	
	Если ДатаВПериоде<>Неопределено Тогда
		
		ТекущийПериод=ОпределитьПериодПоДате(ДатаВПериоде,Периодичность);
		
		Если НЕ ТекущийПериод=Неопределено Тогда
			
			ТекстПериод=ТекстПериод+": "+ТекущийПериод.Наименование;
			
		Иначе
			
			Возврат Неопределено;
			
		КонецЕсли;
		
	КонецЕсли;
	
	Если Периодичность=Перечисления.Периодичность.Неделя Тогда
		
		СтруктураТекст.Вставить("ТекстНачалаПериода","Начало недели"+ТекстПериод);
		СтруктураТекст.Вставить("ТекстОкончанияПериода","Конец недели"+ТекстПериод);
		СтруктураТекст.Вставить("ТекстПредыдущийПериод","Предыдущая неделя"+ТекстПериод);
		СтруктураТекст.Вставить("ТекстСледующийПериод","Следующая неделя"+ТекстПериод);
		СтруктураТекст.Вставить("ТекстТекущийПериод","Текущая неделя"+ТекстПериод);
		
	ИначеЕсли Периодичность=Перечисления.Периодичность.Декада Тогда
		
		СтруктураТекст.Вставить("ТекстНачалаПериода","Начало декады"+ТекстПериод);
		СтруктураТекст.Вставить("ТекстОкончанияПериода","Конец декады"+ТекстПериод);
		СтруктураТекст.Вставить("ТекстПредыдущийПериод","Предыдущая декада"+ТекстПериод);
		СтруктураТекст.Вставить("ТекстСледующийПериод","Следующая декада"+ТекстПериод);
		СтруктураТекст.Вставить("ТекстТекущийПериод","Текущая декада"+ТекстПериод);
		
	ИначеЕсли Периодичность=Перечисления.Периодичность.Месяц Тогда
		
		СтруктураТекст.Вставить("ТекстНачалаПериода","Начало месяца"+ТекстПериод);
		СтруктураТекст.Вставить("ТекстОкончанияПериода","Конец месяца"+ТекстПериод);
		СтруктураТекст.Вставить("ТекстПредыдущийПериод","Предыдущий месяц"+ТекстПериод);
		СтруктураТекст.Вставить("ТекстСледующийПериод","Следующий месяц"+ТекстПериод);
		СтруктураТекст.Вставить("ТекстТекущийПериод","Текущий месяц"+ТекстПериод);
		
	ИначеЕсли Периодичность=Перечисления.Периодичность.Квартал Тогда
		
		СтруктураТекст.Вставить("ТекстНачалаПериода","Начало квартала"+ТекстПериод);
		СтруктураТекст.Вставить("ТекстОкончанияПериода","Конец квартала"+ТекстПериод);
		СтруктураТекст.Вставить("ТекстПредыдущийПериод","Предыдущий квартал"+ТекстПериод);
		СтруктураТекст.Вставить("ТекстСледующийПериод","Следующий квартал"+ТекстПериод);
		СтруктураТекст.Вставить("ТекстТекущийПериод","Текущий квартал"+ТекстПериод);
		
	ИначеЕсли Периодичность=Перечисления.Периодичность.Полугодие Тогда
		
		СтруктураТекст.Вставить("ТекстНачалаПериода","Начало полугодия"+ТекстПериод);
		СтруктураТекст.Вставить("ТекстОкончанияПериода","Конец полугодия"+ТекстПериод);
		СтруктураТекст.Вставить("ТекстПредыдущийПериод","Предыдущее полугодие"+ТекстПериод);
		СтруктураТекст.Вставить("ТекстСледующийПериод","Следующее полугодие"+ТекстПериод);
		СтруктураТекст.Вставить("ТекстТекущийПериод","Текущее полугодие"+ТекстПериод);
		
	ИначеЕсли Периодичность=Перечисления.Периодичность.Год Тогда
		
		СтруктураТекст.Вставить("ТекстНачалаПериода","Начало года"+ТекстПериод);
		СтруктураТекст.Вставить("ТекстОкончанияПериода","Конец года"+ТекстПериод);
		СтруктураТекст.Вставить("ТекстПредыдущийПериод","Предыдущий год"+ТекстПериод);
		СтруктураТекст.Вставить("ТекстСледующийПериод","Следующий год"+ТекстПериод);
		СтруктураТекст.Вставить("ТекстТекущийПериод","Текущий год"+ТекстПериод);
		
	Иначе
		
		Возврат Неопределено;
		
	КонецЕсли;
	
	Возврат СтруктураТекст;
	
КонецФункции // ТекстНачалаКонцаПериода() 

Функция ОпределитьПериодПоДате(ДатаВПериоде,Периодичность) Экспорт
	
	Запрос=Новый Запрос;
	Запрос.Текст="ВЫБРАТЬ ПЕРВЫЕ 1
	|	Периоды.Ссылка,
	|	Периоды.Наименование,
	|	РАЗНОСТЬДАТ(Периоды.ДатаНачала, Периоды.ДатаОкончания, ДЕНЬ) КАК ДнейВПериоде
	|ИЗ
	|	Справочник.Периоды КАК Периоды
	|ГДЕ
	|	Периоды.ДатаНачала <= &ДатаВПериоде
	|	И Периоды.ДатаОкончания >= &ДатаВПериоде
	|	И Периоды.Периодичность = &ТекПериодичность
	|
	|УПОРЯДОЧИТЬ ПО
	|	ДнейВПериоде";
	
	Запрос.УстановитьПараметр("ТекПериодичность",Периодичность);
	Запрос.УстановитьПараметр("ДатаВПериоде",ДатаВПериоде);
	
	Результат=Запрос.Выполнить().Выбрать();
	
	Если Результат.Следующий() Тогда
		
		Возврат Результат.Ссылка;
		
	Иначе
		
		Возврат Неопределено;
		
	КонецЕсли;
	
КонецФункции // ОпределитьПериодПоДате() 

Функция ОпределитьДатуПлатежа(ДатаВПериоде,
	ПериодичностьПлатежа,
	ПериодичностьСмещенияДатыПлатежа,
	СмещениеПериодовОтНачалаЦикла,
	СмещениеДатыПлатежаОтНачалаПериода) Экспорт
	
	// Определяем дату начала платежного периода
	
	НачалоИсходногоПериода=ДатаНачалаПериода(ДатаВПериоде,ПериодичностьПлатежа);
	
	// Определяем дату начала периода, определенного для платежа
	НачалоПлатежногоПериода=ДобавитьИнтервал(НачалоИсходногоПериода,ПериодичностьСмещенияДатыПлатежа,?(СмещениеПериодовОтНачалаЦикла=0,0,СмещениеПериодовОтНачалаЦикла-1));
	
	Если НЕ ПериодичностьСмещенияДатыПлатежа=Перечисления.Периодичность.День Тогда
		
		// Определяем день по смещению от даты начала периода, определенного для платежа 
		НачалоПлатежногоПериода=ДобавитьИнтервал(НачалоПлатежногоПериода,Перечисления.Периодичность.День,?(СмещениеДатыПлатежаОтНачалаПериода=0,0,СмещениеДатыПлатежаОтНачалаПериода-1));
		
	КонецЕсли;
	
	ДатаПлатежа=ОпределитьРабочуюДату(НачалоПлатежногоПериода,0);
	
	Возврат ДатаПлатежа;		
	
КонецФункции // ОпределитьДатуПлатежа()

// Возвращает число дней в переданном периоде
//
// Параметры
//  Периодичность – Перечисление.Периодичность элемент перечисления, 
//		для которого вычисляется количество дней
//
// Возвращаемое значение:
//   ЧислоДнейВПериоде (число)  – число дней в переданном периоде
//
Функция ЧислоДнейВПериоде(Периодичность) Экспорт
	
	Если Периодичность=Перечисления.Периодичность.День Тогда
		ЧислоДнейВПериоде=1;
	ИначеЕсли Периодичность=Перечисления.Периодичность.Неделя Тогда
		ЧислоДнейВПериоде=7;
	ИначеЕсли Периодичность=Перечисления.Периодичность.Месяц Тогда
		ЧислоДнейВПериоде=30;
	ИначеЕсли Периодичность=Перечисления.Периодичность.Квартал Тогда
		ЧислоДнейВПериоде=90;
	ИначеЕсли Периодичность=Перечисления.Периодичность.Год Тогда
		ЧислоДнейВПериоде=365;
	Иначе
		ЧислоДнейВПериоде=0;
	КонецЕсли;
	
	Возврат ЧислоДнейВПериоде;	
	
КонецФункции // ЧислоДнейВПериоде()

Функция ВернутьОтносительнуюДату(ДатаНачала, Периодичность, Смещение) Экспорт
	
	Если Периодичность		= Перечисления.Периодичность.Год 
		ИЛИ Периодичность      = Перечисления.Периодичность.ДевятьМесяцев Тогда
		ДатаНачалаОтносительногоПериода		= ДобавитьМесяц(ДатаНачала, 12 * Смещение);
	ИначеЕсли Периодичность = Перечисления.Периодичность.Полугодие Тогда
		ДатаНачалаОтносительногоПериода		= ДобавитьМесяц(ДатаНачала, 6 * Смещение);
	ИначеЕсли Периодичность = Перечисления.Периодичность.Квартал Тогда
		ДатаНачалаОтносительногоПериода		= ДобавитьМесяц(ДатаНачала, 3 * Смещение);
	ИначеЕсли Периодичность = Перечисления.Периодичность.Месяц Тогда
		ДатаНачалаОтносительногоПериода		= ДобавитьМесяц(ДатаНачала, Смещение);
	ИначеЕсли Периодичность = Перечисления.Периодичность.Декада Тогда
		
		// анализируем
		ГодДатыНачала						= Год(ДатаНачала);
		МесяцДатыНачала						= Месяц(ДатаНачала);
		ДеньДатыНачала						= День(ДатаНачала);
		ДекадаДатыНачала					= Цел((ДеньДатыНачала - 1) / 10) + 1;
		ДекадаДатыНачала					= ?(ДекадаДатыНачала = 4, 3, ДекадаДатыНачала);
		НомерДекадыНЭ						= ГодДатыНачала * 36 + (МесяцДатыНачала - 1) * 3 + (ДекадаДатыНачала - 1);
		
		// изменяем
		НомерДекадыНЭ						= НомерДекадыНЭ + Смещение;
		
		// синтезируем
		ГодДатыНачалаОтнПериода				= Цел((НомерДекадыНЭ)/ 36);
		ДекадаВГоду							= НомерДекадыНЭ % 36;
		МесяцВГодуДатыНачалаОтнПериода		= Цел(ДекадаВГоду / 3) + 1;
		ДекадаВМесяце						= ДекадаВГоду % 3;
		ДеньВМесяцеДатыНачалаОтнПериода		= ДекадаВМесяце * 10 + 1;
		
		ДатаНачалаОтносительногоПериода		= Дата(ГодДатыНачалаОтнПериода, МесяцВГодуДатыНачалаОтнПериода, ДеньВМесяцеДатыНачалаОтнПериода);
		
	ИначеЕсли Периодичность = Перечисления.Периодичность.День Тогда
		ОдинДень							= НачалоДня(Дата(2000, 1, 2)) - НачалоДня(Дата(2000, 1, 1));
		ДатаНачалаОтносительногоПериода		= ДатаНачала + ОдинДень * Смещение;
	Иначе
		Возврат Неопределено;
	КонецЕсли;
	
	Возврат НачалоДня(ДатаНачалаОтносительногоПериода);
	
КонецФункции

Функция глОтносительныйПериодПоДате(ДатаНачала, Периодичность, Смещение, ТихийРежим = Ложь) Экспорт
	
	
	ДатаНачалаОтносительногоПериода = ВернутьОтносительнуюДату(ДатаНачала, Периодичность, Смещение);
	
	Если ДатаНачалаОтносительногоПериода = Неопределено Тогда
		
		Если НЕ ТихийРежим Тогда
			
			СообщитьОбОшибке("Не удалось определить начало относительного периода");
			
		КонецЕсли;
		
		Возврат Неопределено;
		
	КонецЕсли;
	
	Запрос = Новый Запрос("ВЫБРАТЬ ПЕРВЫЕ 1
	|	Периоды.Ссылка
	|ИЗ
	|	Справочник.Периоды КАК Периоды
	|ГДЕ
	|	Периоды.ДатаНачала = &ДатаНачала
	|	И Периоды.Периодичность = &Периодичность");
	Запрос.УстановитьПараметр("ДатаНачала", ДатаНачалаОтносительногоПериода);
	Запрос.УстановитьПараметр("Периодичность", Периодичность);
	Результат = Запрос.Выполнить();
	
	Если Результат.Пустой() Тогда
		
		ОбъектПериод=Справочники.Периоды.СоздатьЭлемент();
		ОбъектПериод.ДатаНачала=ДатаНачалаОтносительногоПериода;
		ОбъектПериод.Периодичность=Периодичность;
		ОбъектПериод.Заполнить(Неопределено);
		
		Попытка
			
			ОбъектПериод.Записать();
			Возврат ОбъектПериод.Ссылка;
			
		Исключение
			
			Если Не ТихийРежим Тогда
				СообщитьОбОшибке("Невозможно определить относительный период (смещение = " + Смещение + "): не существует искомый период в справочнике ""Периоды""! ", , , СтатусСообщения.Важное);
			КонецЕсли;
			
			Возврат Справочники.Периоды.ПустаяСсылка();
			
		КонецПопытки;

	Иначе
		Выборка = Результат.Выбрать();
		Выборка.Следующий();
		Возврат Выборка.Получить(0);
	КонецЕсли;
	
	
КонецФункции

// Функция возвращает модуль значения.
Функция ЗначениеПоМодулю(Значение) Экспорт;
	
	Возврат ?(Значение<0,Значение*-1,Значение);
	
КонецФункции // Модуль() 

Функция глОтносительныйПериод(локПериодОтчета, Смещение, ТихийРежим = Ложь) Экспорт
	
	Если НЕ ЗначениеЗаполнено(локПериодОтчета) Тогда
		Если НЕ ТихийРежим Тогда
			СообщитьОбОшибке("Невозможно определить относительный период (смещение = " + Смещение + "): исходный период не задан! ", , ,СтатусСообщения.Важное);
		КонецЕсли;
		Возврат Справочники.Периоды.ПустаяСсылка();
	КонецЕсли;
	
	Возврат глОтносительныйПериодПоДате(локПериодОтчета.ДатаНачала, локПериодОтчета.Периодичность, Смещение, ТихийРежим);
	
КонецФункции

Функция глАналогичныйПериод(локПериодОтчета, Смещение) Экспорт
	
	Если НЕ ЗначениеЗаполнено(локПериодОтчета) Тогда
		СообщитьОбОшибке("Невозможно определить аналогичный период года (смещение = " + Смещение + "): исходный период не задан! ", , , СтатусСообщения.Важное);
		Возврат Справочники.Периоды.ПустаяСсылка();
	КонецЕсли;
	
	Если локПериодОтчета.Периодичность = Перечисления.Периодичность.Декада Тогда
		
		// анализируем
		ГодДатыНачала						= Год(локПериодОтчета.ДатаНачала);
		МесяцДатыНачала						= Месяц(локПериодОтчета.ДатаНачала);
		ДеньДатыНачала						= День(локПериодОтчета.ДатаНачала);
		ДекадаДатыНачала					= Цел((ДеньДатыНачала - 1) / 10) + 1;
		ДекадаДатыНачала					= ?(ДекадаДатыНачала = 4, 3, ДекадаДатыНачала);
		НомерДекадыНЭ						= ГодДатыНачала * 36 + (МесяцДатыНачала - 1) * 3 + (ДекадаДатыНачала - 1);
		
		// изменяем
		НомерДекадыНЭ						= НомерДекадыНЭ + Смещение;
		
		// синтезируем
		ГодДатыНачалаОтнПериода				= Цел((НомерДекадыНЭ)/ 36);
		ДекадаВГоду							= НомерДекадыНЭ % 36;
		МесяцВГодуДатыНачалаОтнПериода		= Цел(ДекадаВГоду / 3) + 1;
		ДекадаВМесяце						= ДекадаВГоду % 3;
		ДеньВМесяцеДатыНачалаОтнПериода		= ДекадаВМесяце * 10 + 1;
		
		ДатаНачалаОтносительногоПериода		= Дата(ГодДатыНачалаОтнПериода+Смещение, МесяцВГодуДатыНачалаОтнПериода, ДеньВМесяцеДатыНачалаОтнПериода);
		
	Иначе
		ДатаНачалаОтносительногоПериода		= ДобавитьМесяц(локПериодОтчета.ДатаНачала, 12 * Смещение);
	КонецЕсли;
	
	ДатаНачалаОтносительногоПериода = НачалоДня(ДатаНачалаОтносительногоПериода);
	
	Запрос = Новый Запрос("ВЫБРАТЬ ПЕРВЫЕ 1
	|	Периоды.Ссылка
	|ИЗ
	|	Справочник.Периоды КАК Периоды
	|ГДЕ
	|	Периоды.ДатаНачала = &ДатаНачала
	|	И Периоды.Периодичность = &Периодичность");
	Запрос.УстановитьПараметр("ДатаНачала", ДатаНачалаОтносительногоПериода);
	Запрос.УстановитьПараметр("Периодичность", локПериодОтчета.Периодичность);
	Результат = Запрос.Выполнить();
	Если Результат.Пустой() Тогда
		СообщитьОбОшибке("Невозможно определить аналогичный период (смещение = " + Смещение + "): не существует искомый период в справочнике ""Периоды""! ", , , СтатусСообщения.Важное);
		Возврат Справочники.Периоды.ПустаяСсылка();
	Иначе
		Выборка = Результат.Выбрать();
		Выборка.Следующий();
		Возврат Выборка.Получить(0);
	КонецЕсли;
	
	
КонецФункции

// Функция "расщепляет" строку на подстроки, используя заданный 
//		разделитель. Разделитель может иметь любую длину. 
//		Если в качестве разделителя задан пробел, рядом стоящие пробелы 
//		считаются одним разделителем, а ведущие и хвостовые пробелы параметра Стр
//		игнорируются.
//		Например, 
//		РазложитьСтрокуВМассивПодстрок(",ку,,,му", ",") возвратит массив значений из пяти элементов, 
//		три из которых - пустые строки, а 
//		РазложитьСтрокуВМассивПодстрок(" ку   му", " ") возвратит массив значений из двух элементов
//
//	Параметры: 
//		Стр - 			строка, которую необходимо разложить на подстроки. 
//						Параметр передается по значению.
//		Разделитель - 	строка-разделитель, по умолчанию - запятая.
//
//
//	Возвращаемое значение:
//		массив значений, элементы которого - подстроки
//
Функция РазложитьСтрокуВМассивПодстрок(Знач Стр, Разделитель = ",") Экспорт
	
	МассивСтрок = Новый Массив();
	Если Разделитель = " " Тогда
		Стр = СокрЛП(Стр);
		Пока 1=1 Цикл
			Поз = Найти(Стр,Разделитель);
			Если Поз=0 Тогда
				МассивСтрок.Добавить(Стр);
				Возврат МассивСтрок;
			КонецЕсли;
			МассивСтрок.Добавить(Лев(Стр,Поз-1));
			Стр = СокрЛ(Сред(Стр,Поз));
		КонецЦикла;
	Иначе
		ДлинаРазделителя = СтрДлина(Разделитель);
		Пока 1=1 Цикл
			Поз = Найти(Стр,Разделитель);
			Если Поз=0 Тогда
				МассивСтрок.Добавить(Стр);
				Возврат МассивСтрок;
			КонецЕсли;
			МассивСтрок.Добавить(Лев(Стр,Поз-1));
			Стр = Сред(Стр,Поз+ДлинаРазделителя);
		КонецЦикла;
	КонецЕсли;
	
КонецФункции // глРазложить

Функция РазложитьСтрокуПоЗаглавнымБуквам(Знач Стр) Экспорт
	
	РезультирующаяСтрока=Сред(Стр,1,1);
	
	Для Инд=2 По СтрДлина(Стр) Цикл
		
		ТекСимвол=Сред(Стр,Инд,1);
		
		Если ТекСимвол=ВРЕГ(ТекСимвол) Тогда
			
			РезультирующаяСтрока=РезультирующаяСтрока+" "+НРЕГ(ТекСимвол);
			
		Иначе
			
			РезультирующаяСтрока=РезультирующаяСтрока+ТекСимвол;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат РезультирующаяСтрока;
	
КонецФункции // РазложитьСтрокуПоЗаглавнымБуквам()

// Процедура устанавливает доступность элементов управления отбором списка.
//
// Параметры:
//  ТабличноеПоле      - табличное поле списка.
//  ОбязательныеОтборы - список имен обязательных отборов, у которых доступность отключается.
//
Процедура УстановитьДоступностьОтбора(ТабличноеПоле, Знач ОбязательныеОтборы = "") Экспорт
	
	ОбязательныеОтборы = Врег(ОбязательныеОтборы) + ", ";
	
	Для каждого ЭлементУправленияОтбором Из ТабличноеПоле.НастройкаОтбора Цикл
		ОбязательныйОтбор = Найти(ОбязательныеОтборы, Врег(ЭлементУправленияОтбором.Имя)) > 0;
		
		ЭлементУправленияОтбором.Доступность = НЕ ОбязательныйОтбор;
	КонецЦикла;
	
КонецПроцедуры

// Процедура устанавливает доступность всех элементов управления порядком списка.
//
// Параметры:
//  ТабличноеПоле - табличное поле списка.
//
Процедура УстановитьДоступностьПорядка(ТабличноеПоле, Доступность = Истина) Экспорт
	
	Для каждого ЭлементУправленияПорядком Из ТабличноеПоле.НастройкаПорядка Цикл
		ЭлементУправленияПорядком.Доступность = Доступность;
	КонецЦикла;
	
КонецПроцедуры

// Добавляет в таблицу значений строки из другой таблицы значений и 
// в них значения колонок с совпадающими наименованиями.
//
// Параметры:
//  ТаблицаИсточник - таблица значений, откуда берутся значения.
//  ТаблицаПриемник - таблица значений, куда добавляются строки.
//
Процедура ЗагрузитьВТаблицуЗначений(ТаблицаИсточник, ТаблицаПриемник) Экспорт
	
	// Заполним значения в совпадающих колонках.
	Для каждого СтрокаТаблицыИсточника Из ТаблицаИсточник Цикл
		
		СтрокаТаблицыПриемника = ТаблицаПриемник.Добавить();
		ЗаполнитьЗначенияСвойств(СтрокаТаблицыПриемника, СтрокаТаблицыИсточника);
		
	КонецЦикла;
	
КонецПроцедуры // ЗагрузитьВТаблицуЗначений()

// Добавляет значения из переданного массива в переданный список значений
//
Процедура ДобавитьМассивВСписокЗначений(СписокЗначений, Массив) Экспорт
	
	Для Каждого Значение ИЗ Массив Цикл
		
		СписокЗначений.Add(Значение);
		
	КонецЦикла;
	
КонецПроцедуры // ДобавитьМассивВСписокЗначений()

// Добавляет к строке дерева значений полную коллекцию строк другого дерева значений
//
Процедура ДобавитьКоллекциюВСтрокуДереваЗначений(СтрокаДерева,КоллекцияСтрок) Экспорт
	
	Для Каждого Строка ИЗ КоллекцияСтрок Цикл
		
		НоваяСтрока=СтрокаДерева.Строки.Добавить();
		ЗаполнитьЗначенияСвойств(НоваяСтрока,Строка);
		
		Если Строка.Строки.Количество()>0 Тогда
			
			ДобавитьКоллекциюВСтрокуДереваЗначений(НоваяСтрока,Строка.Строки);
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат;
	
КонецПроцедуры

// Удаляет неиспользуемые способы вычисления параметров из таблиц их вычисления
//
Процедура УдалитьНеиспользуемыеПараметры(ТабВычисления)
	
	МассивНеиспользуемых=ТабВычисления.НайтиСтроки(Новый Структура("СпособВычисленияПараметра",Перечисления.СпособыВычисленияПараметровОперандов.НеИспользуется));
	
	Для Каждого Строка Из МассивНеиспользуемых Цикл
		
		ТабВычисления.Удалить(Строка);
		
	КонецЦикла;
	
КонецПроцедуры // УдалитьНеиспользуемыеПараметры()

// Функция сравнивает две таблицы вычисления параметров операндов
//
// Параметры
//  ТаблицаВычисления1 - ТаблицаЗначений для сравнения
//  ТаблицаВычисления2 - ТаблицаЗначений для сравнения
//
// Возвращаемое значение:
//   Булево, идентичны или нет две таблицы
//
Функция СравнитьТаблицыВычисленияПараметров(РабочаяТаблица1, РабочаяТаблица2) Экспорт
	
	ТаблицаВычисления1=РабочаяТаблица1.Скопировать();
	ТаблицаВычисления2=РабочаяТаблица2.Скопировать();
	
	УдалитьНеиспользуемыеПараметры(ТаблицаВычисления1);
	УдалитьНеиспользуемыеПараметры(ТаблицаВычисления2);
	
	Если ТаблицаВычисления1.Количество() <> ТаблицаВычисления2.Количество() Тогда
		Возврат Ложь;
	КонецЕсли; 
	
	ТаблицаВычисления1.Сортировать("ИмяПараметра");
	ТаблицаВычисления2.Сортировать("ИмяПараметра");
	
	МассивКолонок=Новый Массив;
	МассивКолонок.Добавить("ИмяПараметра");
	МассивКолонок.Добавить("СпособВычисленияПараметра");
	МассивКолонок.Добавить("УточнениеСпособаОпределения");
	
	Для Индекс=0 По ТаблицаВычисления1.Количество()-1 Цикл
		
		Для Каждого Колонка ИЗ МассивКолонок Цикл
			
			Если Колонка="УточнениеСпособаОпределения" Тогда
				
				ЗначениеДляПроверки1=ТаблицаВычисления1[Индекс].УточнениеСпособаОпределения.Получить();
				ЗначениеДляПроверки2=ТаблицаВычисления2[Индекс].УточнениеСпособаОпределения.Получить();
				
				Если ТипЗнч(ЗначениеДляПроверки1)=Тип("Структура") Тогда
					
					Если Не СравнитьСтруктурыЗначений(ЗначениеДляПроверки1,ЗначениеДляПроверки2) Тогда
						
						Возврат Ложь;
						
					КонецЕсли;
					
				ИначеЕсли ТипЗнч(ЗначениеДляПроверки1)=Тип("СписокЗначений") Тогда
					
					Если НЕ СравнитьСпискиЗначений(ЗначениеДляПроверки1,ЗначениеДляПроверки2) Тогда
						
						Возврат Ложь;
						
					КонецЕсли;
					
				ИначеЕсли ТипЗнч(ЗначениеДляПроверки1)=Тип("Массив") Тогда 
					
					Если НЕ СравнитьМассивыЗначений(ЗначениеДляПроверки1,ЗначениеДляПроверки2)Тогда
						
						Возврат Ложь;
						
					КонецЕсли;
					
				ИначеЕсли НЕ ЗначениеДляПроверки1=ЗначениеДляПроверки2 Тогда
					
					Возврат Ложь;
					
				КонецЕсли;
				
			ИначеЕсли НЕ ТаблицаВычисления1[Индекс][Колонка]=ТаблицаВычисления2[Индекс][Колонка] Тогда
				
				Возврат Ложь;
				
			КонецЕсли;
			
		КонецЦикла;
		
	КонецЦикла;
	
	Возврат Истина;
	
КонецФункции // СравнитьТаблицыВычисленияПараметров()

Функция СравнитьТаблицыЗначений(ТаблицаЗначений1, ТаблицаЗначений2,СтруктураПропускаемыхЗначений=Неопределено) Экспорт
	
	Если ТипЗнч(ТаблицаЗначений1) <> Тип("ТаблицаЗначений") ИЛИ ТипЗнч(ТаблицаЗначений2) <> Тип("ТаблицаЗначений") Тогда
		Возврат Ложь;
	КонецЕсли; 
	
	Если ТаблицаЗначений1.Количество() <> ТаблицаЗначений2.Количество() Тогда
		Возврат Ложь;
	КонецЕсли; 
	
	Если ТаблицаЗначений1.Колонки.Количество() <> ТаблицаЗначений2.Колонки.Количество() Тогда
		Возврат Ложь;
	КонецЕсли;
	
	// Проверим поля
	Для каждого Колонка Из ТаблицаЗначений1.Колонки Цикл
		Если ТаблицаЗначений2.Колонки.Найти(Колонка.Имя) = Неопределено Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла; 
	Для каждого Колонка Из ТаблицаЗначений2.Колонки Цикл
		Если ТаблицаЗначений1.Колонки.Найти(Колонка.Имя) = Неопределено Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла; 
	
	// сформируем строку индекса для оптимизации поиска по таблице значений
	СтрокаИндекса = "";
	Для каждого Колонка Из ТаблицаЗначений1.Колонки Цикл
		Если СтрокаИндекса = "" Тогда
			СтрокаИндекса = Колонка.Имя;
		Иначе
			СтрокаИндекса = СтрокаИндекса+","+Колонка.Имя;
		КонецЕсли;
	КонецЦикла;
	// добавим индекс
	ТаблицаЗначений2.Индексы.Добавить(СтрокаИндекса);
	
	// Проверим записи
	Для каждого СтрокаТаблицы Из ТаблицаЗначений1 Цикл
		СтруктураПоиска = Новый Структура;
		
		НеобходимПоиск=Истина;
		
		Для каждого Колонка Из ТаблицаЗначений1.Колонки Цикл
			
			Если СтруктураПропускаемыхЗначений=Неопределено 
				ИЛИ НЕ(СтруктураПропускаемыхЗначений.Свойство(Колонка.Имя) И СтруктураПропускаемыхЗначений[Колонка.Имя]=СтрокаТаблицы[Колонка.Имя]) Тогда
				
				СтруктураПоиска.Вставить(Колонка.Имя, СтрокаТаблицы[Колонка.Имя]);
				
			Иначе
				
				НеобходимПоиск=Ложь
				
			КонецЕсли;
			
		КонецЦикла;
		
		Если НЕ НеобходимПоиск Тогда
			Продолжить;
		КонецЕсли;
		
		СтрокиТаблицы2 = ТаблицаЗначений2.НайтиСтроки(СтруктураПоиска);
		Если СтрокиТаблицы2.Количество() <> 1 Тогда
			Возврат Ложь;
		КонецЕсли; 
	КонецЦикла;
	
	// сформируем строку индекса для оптимизации поиска по таблице значений
	СтрокаИндекса = "";
	Для каждого Колонка Из ТаблицаЗначений2.Колонки Цикл
		Если СтрокаИндекса = "" Тогда
			СтрокаИндекса = Колонка.Имя;
		Иначе
			СтрокаИндекса = СтрокаИндекса+","+Колонка.Имя;
		КонецЕсли;
	КонецЦикла;
	// добавим индекс
	ТаблицаЗначений1.Индексы.Добавить(СтрокаИндекса);
	
	Для каждого СтрокаТаблицы Из ТаблицаЗначений2 Цикл
		СтруктураПоиска = Новый Структура;
		НеобходимПоиск=Истина;
		
		Для каждого Колонка Из ТаблицаЗначений1.Колонки Цикл
			
			Если СтруктураПропускаемыхЗначений=Неопределено 
				ИЛИ НЕ(СтруктураПропускаемыхЗначений.Свойство(Колонка.Имя) И СтруктураПропускаемыхЗначений[Колонка.Имя]=СтрокаТаблицы[Колонка.Имя]) Тогда
				
				СтруктураПоиска.Вставить(Колонка.Имя, СтрокаТаблицы[Колонка.Имя]);
				
			Иначе
				
				НеобходимПоиск=Ложь
				
			КонецЕсли;
			
		КонецЦикла;
		
		Если НЕ НеобходимПоиск Тогда
			Продолжить;
		КонецЕсли;
		
		СтрокиТаблицы1 = ТаблицаЗначений1.НайтиСтроки(СтруктураПоиска);
		Если СтрокиТаблицы1.Количество() <> 1 Тогда
			Возврат Ложь;
		КонецЕсли; 
	КонецЦикла;
	
	Возврат Истина;
	
КонецФункции // СравнитьТаблицыЗначений()

Функция ПолучитьСтрокуИзСпискаЗначений(СписокЗначений) Экспорт
	
	СтрокаСписок="";
	
	Для Каждого Элемент ИЗ СписокЗначений Цикл
		СтрокаСписок=СтрокаСписок+";"+Элемент.Значение;
	КонецЦикла;
	
	Возврат Сред(СтрокаСписок,2);
	
КонецФункции // ПолучитьСтрокуИзСпискаЗначений() 

// Функция формирует список элементов перечисления
//
// Параметры
//  ИмяПеречисления - имя перечисления, как оно задано в конфигураторе
//
// Возвращаемое значение:
//   СписокЗначений - список элементов перечисления
//
Функция ПолучитьСписокЭлементовПеречисления(ИмяПеречисления) Экспорт
	
	СписокЭлементовПеречисления = Новый СписокЗначений;
	
	Попытка
		КоллекцияЭлементовПеречисления = Перечисления[ИмяПеречисления];
	Исключение
		Возврат СписокЭлементовПеречисления;
	КонецПопытки;
	
	Для каждого ЭлементПеречисления Из КоллекцияЭлементовПеречисления Цикл
		СписокЭлементовПеречисления.Добавить(ЭлементПеречисления, Строка(ЭлементПеречисления));
	КонецЦикла;
	
	Возврат СписокЭлементовПеречисления;
	
КонецФункции // ПолучитьСписокЭлементовПеречисления()


// Процедура проверяет уникальность строк табличной части
//
Процедура ПроверитьУникальностьСтрокТабличнойЧасти(ТабличнаяЧасть, ИмяКолонки, Отказ, ШапкаОшибки, ЗапретНезаполненныхЗначений = Ложь) Экспорт
	
	СоответствиеНеуникальных = Новый Соответствие;
	
	Для каждого СтрокаТаблицы Из ТабличнаяЧасть Цикл
		
		Значение = СтрокаТаблицы[ИмяКолонки];
		СтрокаВстречалась = СоответствиеНеуникальных[Значение];
		
		Если СтрокаВстречалась = Неопределено Тогда
			
			
			СоответствиеНеуникальных.Вставить(Значение, 1);
			Если ЗапретНезаполненныхЗначений и НЕ(ЗначениеЗаполнено(Значение)) Тогда
				
				МетаданныеТЧ         = Метаданные.НайтиПоТипу(ТипЗНЧ(ТабличнаяЧасть));
				ПредставлениеКолонки = МетаданныеТЧ.Реквизиты[ИмяКолонки].Представление();
				ПредставлениеТЧ      = МетаданныеТЧ.Представление();
				СообщитьОбОшибке("Значение реквизита """ + ПредставлениеКолонки + """ в табличной части """ + ПредставлениеТЧ + """ строка:" + СтрокаТаблицы.НомерСтроки + " не может быть пустым!", Отказ, ШапкаОшибки);
				
			КонецЕсли;
			
		Иначе
			Если СтрокаВстречалась = 1 Тогда
				МетаданныеТЧ         = Метаданные.НайтиПоТипу(ТипЗНЧ(ТабличнаяЧасть));
				ПредставлениеКолонки = МетаданныеТЧ.Реквизиты[ИмяКолонки].Представление();
				ПредставлениеТЧ      = МетаданныеТЧ.Представление();
				СоответствиеНеуникальных.Вставить(Значение, 2);
				СообщитьОбОшибке("Значение """ +Значение + """ реквизита """ + ПредставлениеКолонки + """ в табличной части """ + ПредставлениеТЧ + """ не уникально!", Отказ, ШапкаОшибки);
			КонецЕсли;
			
		КонецЕсли;
		
	КонецЦикла;
	
КонецПроцедуры

// Процедура вставляет ключи в структуру, если их там нет.
//
// Параметры:
//  Структура - Структура, в которую добавляются ключи.
//  Ключи     - Строка - список ключей, разделенных запятыми.
//
Процедура ВставитьКлючи(Структура, Знач Ключи) Экспорт
	
	Ключи = СтрЗаменить(Ключи, " ", "");
	Ключи = СтрЗаменить(Ключи, ",", Символы.ПС);
	
	Для Номер = 1 По СтрЧислоСтрок(Ключи) Цикл
		Ключ = СтрПолучитьСтроку(Ключи, Номер);
		
		Если НЕ ПустаяСтрока(Ключ) Тогда
			Структура.Вставить(Ключ);
		КонецЕсли;
	КонецЦикла;
	
КонецПроцедуры

// Заполняет стркутуру представлений реквизтов.
//
// Параметры:
//  СтруктураРеквизитов - (Структуура) - ключ - имя реквизита, значение - представление реквизита.
//  КоллекцияРеквизитов - (Коллекция ОбъектМетаданных) - коллекция реквизитов.
//
Процедура ЗаполнитьПредставленияРеквизитов(СтруктураРеквизитов, КоллекцияРеквизитов) Экспорт
	
	Для каждого Реквизит Из КоллекцияРеквизитов Цикл
		СтруктураРеквизитов.Вставить(Реквизит.Имя, Реквизит.Представление());
	КонецЦикла;
	
КонецПроцедуры

// Проверяет не изменяемые реквизиты объекта.
// У объекта должен быть определен экспортируемый метод НеИзменяемыеРеквизиты().
// У объекта должена быть определена экспортируемая переменная СтруктураРеквизитов.
//
// Параметры:
//  Объект    - объект, реквизиты которого проверяются.
//  Отказ     - Истина, если проверка выявила проблемы. В противном случае не меняется.
//              В параметр удобно передавать параметр Отказ обработчика ПередЗаписью.
//  Сообщение - строка, в которую будут дописаны "замечания", выявленные при проверке.
//              Сформированная таким образом строка может использоваться в вызывающей
//              процедуре в качестве сообщения или предупреждения.
//
Процедура ПроверитьНеИзменяемыеРеквизиты(Объект, Отказ, ШапкаОшибки = "") Экспорт
	//___m.s.120826___VA___Begin___
	//Если Объект.Ссылка.Пустая() Тогда
	//	Возврат;
	//КонецЕсли;
	//
	//Для каждого ЭлементСтруктуры Из Объект.НеИзменяемыеРеквизиты() Цикл
	//	ИмяРеквизита = ЭлементСтруктуры.Ключ;
	//	
	//	Если Объект.Метаданные().ТабличныеЧасти.Найти(ИмяРеквизита) = Неопределено Тогда
	//		Если Объект[ИмяРеквизита] <> Объект.Ссылка[ИмяРеквизита] Тогда
	//			СообщитьОбОшибке("- Запрещено изменение реквизита """ + Объект.СтруктураРеквизитов[ИмяРеквизита] + """.", Отказ,  ШапкаОшибки);
	//		КонецЕсли;
	//	Иначе
	//		Если ЗначениеВСтрокуВнутр(Объект[ИмяРеквизита].Выгрузить()) <> ЗначениеВСтрокуВнутр(Объект.Ссылка[ИмяРеквизита].Выгрузить()) Тогда
	//			СообщитьОбОшибке("- Запрещено изменение табличной части """ + Объект.СтруктураРеквизитов[ИмяРеквизита] + """.", Отказ,  ШапкаОшибки);
	//		КонецЕсли;
	//	КонецЕсли;
	//	
	//КонецЦикла;
	//___m.s.120826___VA___End___
	
КонецПроцедуры

// Считывает значение настройки из структуры настроек и присваивает его приемнику, 
// выполняя необходимые проверки
//
// Параметры:
//  СтруктураНастроек - Структура - структура применяемых настроек.
//  КлючЗначения      - Строка - ключ применяемой настройки.
//  ПриемникЗначения  - в этот параметр будет записано значение настройки.
//  ТипЗначения       - Строка - тип, который должно иметь значение настройки.
//
Процедура ПрименитьЭлементНастройкиФормы(СтруктураНастроек, КлючЗначения, ПриемникЗначения, ТипЗначения) Экспорт
	
	Перем Значение;
	
	Если ТипЗнч(СтруктураНастроек) = Тип("Структура") Тогда
		СтруктураНастроек.Свойство(КлючЗначения, Значение);
	КонецЕсли;
	
	Если ТипЗнч(Значение) = Тип(ТипЗначения) Тогда
		ПриемникЗначения = Значение;
	КонецЕсли;
	
КонецПроцедуры

// Процедура заполняет представления элементов всех коллекций построителя отчета на
//  основании соответствия имен и представдлений переданных в параметре
//
// Параметры
//  СтруктураСоответствияИмен - Структура, ключ - имя поля, значение - представление поля
//  ПостроительОтчета         - ПостроительОтчета
//
//  Возвращаемое значение
//   НЕТ
//
Процедура ЗаполнитьПредставленияПолей(СтруктураСоответствияИмен, ПостроительОтчета) Экспорт
	
	СтруктураКоллекцийПостроителяОтчета = Новый Структура("ДоступныеПоля, ВыбранныеПоля, ИзмеренияКолонки, ИзмеренияСтроки, Отбор");
	
	Для каждого ЭлементСтруктуры Из СтруктураКоллекцийПостроителяОтчета Цикл
		Для а = 0 По ПостроительОтчета[ЭлементСтруктуры.Ключ].Количество() - 1 Цикл
			Если ПустаяСтрока(ПостроительОтчета[ЭлементСтруктуры.Ключ][а].Имя) Тогда
				Продолжить;
			КонецЕсли;
			Если СтруктураСоответствияИмен.Свойство(ПостроительОтчета[ЭлементСтруктуры.Ключ][а].Имя) Тогда
				ПостроительОтчета[ЭлементСтруктуры.Ключ][а].Представление = СтруктураСоответствияИмен[ПостроительОтчета[ЭлементСтруктуры.Ключ][а].Имя];
			КонецЕсли; 
		КонецЦикла; 
	КонецЦикла; 
	
КонецПроцедуры // ЗаполнитьПредставленияПолей()

#Если Клиент Тогда
	// При значении параметра ФормаТолькоПросмотр = Истина процедура устанавливает все элементы формы в режим Только просмотр, 
	// оставляя при этом возможность открытия и копирования текста для реквизитов табличных полей
	// 
	// Параметры:
	//
	// 		Контекст			(Тип: Форма) - контекст формы
	//  	ФормаТолькоПросмотр (Тип: Булево)- флаг доступности формы
	Процедура УстановитьДоступностьФормы(Контекст,ФормаТолькоПросмотр, МассивИменИсключений = Неопределено) Экспорт
		
		Если ФормаТолькоПросмотр Тогда
			
			ДоступныеДействияКомПанелей = Новый СписокЗначений(); 
			ДоступныеДействияКомПанелей.Добавить("Закрыть");
			ДоступныеДействияКомПанелей.Добавить("Справка");
			ДоступныеДействияКомПанелей.Добавить("Найти в списке");
			ДоступныеДействияКомПанелей.Добавить("Перечитать");
			ДоступныеДействияКомПанелей.Добавить("Скопировать");
			
			Для Каждого ЭлФормы Из Контекст.ЭлементыФормы Цикл
				
				Если МассивИменИсключений <> Неопределено
					И МассивИменИсключений.Найти(ЭлФормы.Имя) <> Неопределено Тогда
					Продолжить;
				КонецЕсли;
				
				Если ТипЗнч(ЭлФормы) = Тип("ТабличноеПоле") Тогда
					
					ЭлФормы.ИзменятьСоставСтрок = Ложь; 
					
					Для Каждого Колонка Из ЭлФормы.Колонки Цикл
						ЭУ = Колонка.ЭлементУправления;
						Если ТипЗнч(ЭУ) = Тип("ПолеВвода") Тогда
							ЭУ.КнопкаВыбора 		= Ложь;
							ЭУ.КнопкаСпискаВыбора 	= Ложь;
							ЭУ.КнопкаОчистки 		= Ложь;
							ЭУ.ВыбиратьТип			= Ложь;
							ЭУ.ТолькоПросмотр 		= Истина; 
						Иначе
							Колонка.ТолькоПросмотр = Истина; 
						КонецЕсли;  
					КонецЦикла; 
					
				ИначеЕсли ТипЗнч(ЭлФормы) = Тип("КоманднаяПанель") Тогда 
					
					Для Каждого Кнопка Из ЭлФормы.Кнопки Цикл
						
						Если МассивИменИсключений <> Неопределено 
							И МассивИменИсключений.Найти(Кнопка.Имя) <> Неопределено Тогда
							Продолжить;
						КонецЕсли;
						
						Если Кнопка.ТипКнопки = ТипКнопкиКоманднойПанели.Действие Тогда
							Действие = ДоступныеДействияКомПанелей.НайтиПоЗначению(Строка(Кнопка.Действие));
							Если Действие = Неопределено Тогда
								Кнопка.Доступность = Ложь; 
							ИначеЕсли 	(ЭлФормы.Имя = "ОсновныеДействияФормы")
								и		(Действие.Значение = "Закрыть") 
								Тогда 
								Кнопка.КнопкаПоУмолчанию = Истина; 
							КонецЕсли; 
						ИначеЕсли 	Кнопка.ТипКнопки = ТипКнопкиКоманднойПанели.Подменю	Тогда
							Если Не Кнопка.Пояснение = "Перейти к связанной информации" Тогда // другого способа нет
								Кнопка.Кнопки.Очистить();
							КонецЕсли; 
						КонецЕсли;        
					КонецЦикла; 
					
				ИначеЕсли 	ТипЗнч(ЭлФормы) = Тип("Надпись") Тогда
					
					ЭлФормы.Доступность = ?(ЭлФормы.Гиперссылка = Истина, Ложь, Истина);
					
				ИначеЕсли 	ТипЗнч(ЭлФормы) = Тип("Панель") Тогда
					
					Продолжить;
					
				Иначе	
					Попытка
						ЭлФормы.ТолькоПросмотр 	= Истина;
					Исключение
						ЭлФормы.Доступность 	= Ложь;
					КонецПопытки; 
				КонецЕсли;
			КонецЦикла; 
		КонецЕсли;
		
	КонецПроцедуры
	
	// Функция спрашивает пользователя записать ли объект, или нет, если он новый
	//
	// Параметры
	//  ФормаОбъекта - Форма объекта, из которой пытаются произвести действия
	//
	// Возвращаемое значение:
	//   Булево - Объект записан или нет
	//
	Функция ЗаписатьНовыйОбъектВФорме(ФормаОбъекта) Экспорт
		
		Если ФормаОбъекта.ЭтоНовый() Тогда
			Если Документы.ТипВсеСсылки().СодержитТип(ТипЗнч(ФормаОбъекта.ЭтотОбъект.Ссылка)) Тогда
				ТекстВопроса = "Для выполнения данной операции необходимо записать документ. Записать?";
			Иначе // Справочник
				ТекстВопроса = "Для выполнения данной операции необходимо записать элемент. Записать?";
			КонецЕсли; 
			Ответ = Вопрос(ТекстВопроса, РежимДиалогаВопрос.ДаНет);
			Если Ответ <> КодВозвратаДиалога.Да Тогда
				Возврат Ложь;
			Иначе
				Попытка
					Возврат ФормаОбъекта.ЗаписатьВФорме();
				Исключение
					СообщитьОбОшибке(ОписаниеОшибки(),, (Строка(ФормаОбъекта.ЭтотОбъект) + " не записан."));
					Возврат Ложь;
				КонецПопытки;
			КонецЕсли;
		Иначе
			Возврат Истина;
		КонецЕсли; 
		
	КонецФункции // ЗаписатьНовыйОбъектВФорме()
	
#КонецЕсли

// Функция выполняет пропорциональное распределение суммы в соответствии
// с заданными коэффициентами распределения
//
// Параметры:
//		ИсхСумма - распределяемая сумма
//		МассивКоэф - массив коэффициентов распределения
//		Точность - точность округления при распределении. Необязателен.
//      ПроверкаНулевыхЗначений - определяет, будут ли распределяться нулевые значения
//      ИмяКолонки - имя колонки, содержещей коэффициент для распределения в случае, если передан массив строк
//
//	Возврат:
//		МассивСумм - массив размерностью равный массиву коэффициентов, содержит
//			суммы в соответствии с весом коэффициента (из массива коэффициентов)
//          В случае если распределить не удалось (сумма = 0, кол-во коэф. = 0,
//          или суммарный вес коэф. = 0), тогда возвращается значение Неопределено
//
Функция РаспределитьПропорционально(Знач ИсхСумма, МассивКоэф, Знач Точность = 2, ПроверкаНулевыхЗначений=Истина,ИмяКолонки="") Экспорт
	
	Если МассивКоэф.Количество() = 0 Или (ПроверкаНулевыхЗначений И ИсхСумма = 0) Или ИсхСумма = Null Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	СуммаКоэф  = 0;
	
	Для К = 0 По МассивКоэф.Количество() - 1 Цикл
		СуммаКоэф = СуммаКоэф + ?(ИмяКолонки="",МассивКоэф[К],МассивКоэф[К][ИмяКолонки]);
	КонецЦикла;
	
	Если СуммаКоэф = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	МассивСумм = Новый Массив(МассивКоэф.Количество());
	
	Для К = 0 По МассивКоэф.Количество() - 1 Цикл
		
		ТекКоэфф=?(ИмяКолонки="",МассивКоэф[К],МассивКоэф[К][ИмяКолонки]);
		
		МассивСумм[К] = ?(СуммаКоэф <> 0, Окр(ИсхСумма * ТекКоэфф / СуммаКоэф, Точность, 1), 0);
		ИсхСумма = ИсхСумма - МассивСумм[К]; 
		СуммаКоэф = СуммаКоэф - ТекКоэфф; 
	КонецЦикла;
	
	Возврат МассивСумм;
	
КонецФункции // РаспределитьПропорционально()

Процедура ПометитьСправочникПоРеквизиту(ИмяСправочника,ИмяРеквизита,ЗначениеРеквизита,Пометка,Отказ) Экспорт
	
	Запрос=Новый Запрос;
	
	ТекстОтборПоРеквизитам="";
	
	Если ТипЗнч(ИмяРеквизита)=Тип("Массив") Тогда
		
		Для Каждого Реквизит ИЗ ИмяРеквизита Цикл
			
			ТекстОтборПоРеквизитам=ТекстОтборПоРеквизитам+" ИЛИ "+ИмяСправочника+"."+Реквизит+"=&ЗначениеРеквизита";
			
		КонецЦикла;
		
		ТекстОтборПоРеквизитам="("+Сред(ТекстОтборПоРеквизитам,5)+")";
		
	Иначе
		
		ТекстОтборПоРеквизитам=ИмяСправочника+"."+ИмяРеквизита+"=&ЗначениеРеквизита";
		
	КонецЕсли;
	
	Запрос.Текст="ВЫБРАТЬ
	|"+ИмяСправочника+".Ссылка
	|ИЗ
	|	Справочник."+ИмяСправочника+" КАК "+ИмяСправочника+"
	|ГДЕ
	|	(НЕ "+ИмяСправочника+".ПометкаУдаления=&ПометкаУдаления)
	|	И "+ТекстОтборПоРеквизитам;
	
	Запрос.УстановитьПараметр("ЗначениеРеквизита",ЗначениеРеквизита);
	Запрос.УстановитьПараметр("ПометкаУдаления",Пометка);
	
	Результат=Запрос.Выполнить().Выбрать();
	
	Пока Результат.Следующий() Цикл
		
		ОбъектСправочник=Результат.Ссылка.ПолучитьОбъект();
		ОбъектСправочник.ПометкаУдаления=Пометка;
		ОбъектСправочник.ОбменДанными.Загрузка=Истина;
				
		Попытка
			
			ОбъектСправочник.Записать();
			
		Исключение
			
			СообщитьОбОшибке("Не удалось изменить пометку удаления для элемента справочника
			|"+ИмяСправочника+" "+Результат.Ссылка+"
			|"+ОписаниеОшибки(),Отказ,,СтатусСообщения.Внимание);
			
			Возврат;
			
		КонецПопытки;
		
	КонецЦикла;
	
КонецПроцедуры // ПометитьСправочникПоРеквизиту()

Процедура ПометитьСправочникПоРеквизитуТЧ(ИмяСправочника,ИмяТЧ,ИмяРеквизитаТЧ,ЗначениеРеквизитаТЧ,Пометка,Отказ) Экспорт
	
	ТекстОтборПоРеквизитам="";
	
	Если ТипЗнч(ИмяРеквизитаТЧ)=Тип("Массив") Тогда
		
		Для Каждого Реквизит ИЗ ИмяРеквизитаТЧ Цикл
			
			ТекстОтборПоРеквизитам=ТекстОтборПоРеквизитам+" ИЛИ "+ИмяСправочника+ИмяТЧ+"."+Реквизит+"=&ЗначениеРеквизита";
			
		КонецЦикла;
		
		ТекстОтборПоРеквизитам="("+Сред(ТекстОтборПоРеквизитам,5)+")";
		
	Иначе
		
		ТекстОтборПоРеквизитам=ИмяСправочника+ИмяТЧ+"."+ИмяРеквизитаТЧ+"=&ЗначениеРеквизита";
		
	КонецЕсли;	
	
	Запрос=Новый Запрос;
	Запрос.Текст="ВЫБРАТЬ
	|"+ИмяСправочника+ИмяТЧ+".Ссылка
	|ИЗ
	|	Справочник."+ИмяСправочника+"."+ИмяТЧ+" КАК "+ИмяСправочника+ИмяТЧ+"
	|ГДЕ
	|	(НЕ "+ИмяСправочника+ИмяТЧ+".Ссылка.ПометкаУдаления = &ПометкаУдаления)
	|	И "+ТекстОтборПоРеквизитам;
	
	Запрос.УстановитьПараметр("ЗначениеРеквизита",ЗначениеРеквизитаТЧ);
	Запрос.УстановитьПараметр("ПометкаУдаления",Пометка);
	
	Результат=Запрос.Выполнить().Выбрать();
	
	Пока Результат.Следующий() Цикл
		
		ОбъектСправочник=Результат.Ссылка.ПолучитьОбъект();
		ОбъектСправочник.ПометкаУдаления=Пометка;
		ОбъектСправочник.ОбменДанными.Загрузка=Истина;
		
		Попытка
			
			ОбъектСправочник.Записать();
			
		Исключение
			
			СообщитьОбОшибке("Не удалось изменить пометку удаления для элемента справочника
			|"+ИмяСправочника+" "+Результат.Ссылка+"
			|"+ОписаниеОшибки(),Отказ,,СтатусСообщения.Внимание);
			
			Возврат;
			
		КонецПопытки;
		
	КонецЦикла;
	
КонецПроцедуры // ПометитьСправочникПоРеквизиту()

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ РАБОТЫ С КОДАМИ ЭЛЕМЕНТОВ СПРАВОЧНИКОВ.

// Функция заменяет все не алфавитноцифровые символы на знак подчеркивания.
// Параметры
//  Код            - Строка, Значение кода, которое необходимо преобразовать.
// Возвращаемое значение
//  Строка, преобразованное значение кода.
//
Функция ВернутьАлфавитноЦифровоеПредставление(Код, РазрешитьЦифрыВНачале = Ложь, РазрешитьСлужебныеСимволы = Ложь, ЗаменятьНеправильные=Истина) Экспорт
	
	Если ТипЗнч(Код) <> Тип("Строка") Тогда
		Возврат Код;
	КонецЕсли;
	
	РусАлфавит       = "АБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ";
	ЛатАлфавит       = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
	Цифры            = "1234567890";
	СлужебныеСимволы = "\+.";
	
	ТекСтрока  = "";
	
	
	Инд = 1;
	ОбработкаНачала = Истина;
	Пока  Инд <= СтрДлина(Код) Цикл
		
		ТекСимвол = (Сред(Код, Инд, 1));
		
		Если  ОбработкаНачала Тогда
			Если СтрЧислоВхождений(РусАлфавит + ЛатАлфавит + ?(РазрешитьЦифрыВНачале, Цифры, "") + ?(РазрешитьСлужебныеСимволы, СлужебныеСимволы, ""), ВРЕГ(ТекСимвол)) <> 0 Тогда
				ОбработкаНачала = Ложь;
				ТекСтрока = ТекСтрока + ТекСимвол;
			КонецЕсли;
			
		Иначе
			
			Если СтрЧислоВхождений(РусАлфавит + ЛатАлфавит + Цифры + ?(РазрешитьСлужебныеСимволы, СлужебныеСимволы, "") + "_", ВРЕГ(ТекСимвол)) = 0 Тогда
				ТекСтрока = ТекСтрока + ?(ЗаменятьНеправильные,"_","");
			ИначеЕсли ТекСимвол = "/" И РазрешитьСлужебныеСимволы Тогда
				ТекСтрока = ТекСтрока + "\";
			Иначе
				ТекСтрока = ТекСтрока + ТекСимвол;
			КонецЕсли;
			
		КонецЕсли;
		
		Инд = Инд + 1;
		
	КонецЦикла;
	
	Возврат ТекСтрока;
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// МЕХАНИЗМ ПОРЯДКОВЫХ НОМЕРОВ СПРАВОЧНИКА

// Процедура выполняет замену реквизита "ПорядковыйНомер" для элемента справочника "ТекущийЭлемент",
// и соседнего с ним элемента 
//
// ТекущийЭлемент   - Тип СправочникСсылка. Ссылка на элемент, который необходимо переместить
// НаправлениеВверх - Булево. Признак направления. Истина - вверх, Ложь иначе
// ИмяРеквизитовРодителя - Строка, имя реквизита, в пределов которых поддерживается уникальность порядковых номеров
// СправочникСписок - Табличное поле списка справочника
//
Процедура ПереместитьЭлементСправочника(ТекущийЭлемент, НаправлениеВверх = Истина, ИмяРеквизитовРодителя = "Родитель", СправочникСписок = Неопределено) Экспорт
	
	Если НЕ ЗначениеЗаполнено(ТекущийЭлемент) или ТекущийЭлемент.ПометкаУдаления Тогда
		Возврат;
	КонецЕсли;
	
	Если Не СправочникСписок = Неопределено и (Не СправочникСписок.Порядок.Количество() = 1 или Не СправочникСписок.Порядок[0].Данные = "ПорядковыйНомер" или Не СправочникСписок.Порядок[0].Направление = НаправлениеСортировки.Возр) Тогда
		
		# Если Клиент Тогда
			Если Вопрос("Будет установлена сортировка по реквизиту ""Порядковый номер""", РежимДиалогаВопрос.ОКОтмена) = КодВозвратаДиалога.ОК Тогда
				СправочникСписок.Порядок.Установить("ПорядковыйНомер");
			КонецЕсли;
		# КонецЕсли
		
		Возврат;
		
	КонецЕсли;
	
	
	ИмяСправочника = ТекущийЭлемент.Метаданные().Имя;
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("Владелец",        ТекущийЭлемент.Владелец);
	Запрос.УстановитьПараметр("ПорядковыйНомер", ТекущийЭлемент.ПорядковыйНомер);
	
	Запрос.Текст = 
	"ВЫБРАТЬ ПЕРВЫЕ 1
	|	Справочник.ПорядковыйНомер КАК ПорядковыйНомер,
	|	Справочник.Ссылка КАК Ссылка
	|ИЗ
	|	Справочник."+ ИмяСправочника + " КАК Справочник
	|ГДЕ
	|	Не Справочник.ПометкаУдаления";
	Если Не ТекущийЭлемент.Владелец = Неопределено Тогда
		Запрос.Текст = Запрос.Текст + "
		|	И Справочник.Владелец = &Владелец";
	КонецЕсли;
	
	Для каждого КлючИЗначение Из Новый Структура(ИмяРеквизитовРодителя) Цикл
		Запрос.Текст = Запрос.Текст + "
		|И Справочник." + КлючИЗначение.Ключ + " = &" + КлючИЗначение.Ключ;
		Запрос.УстановитьПараметр(КлючИЗначение.Ключ, ТекущийЭлемент[КлючИЗначение.Ключ]);
	КонецЦикла;
	
	Запрос.Текст = Запрос.Текст + "
	|
	|	И Справочник.ПорядковыйНомер " + ?(НаправлениеВверх,"<",">") + " &ПорядковыйНомер
	|
	|УПОРЯДОЧИТЬ ПО
	|	ПорядковыйНомер" + ?(НаправлениеВверх," УБЫВ","");
	
	Результат = Запрос.Выполнить();
	
	Выборка = Результат.Выбрать();
	Если Выборка.Следующий() Тогда
		ТекущийОбъект = ТекущийЭлемент.ПолучитьОбъект();
		Объект        = Выборка.Ссылка.ПолучитьОбъект();
		
		Объект       .ПорядковыйНомер = ТекущийЭлемент.ПорядковыйНомер;
		ТекущийОбъект.ПорядковыйНомер = Выборка       .ПорядковыйНомер;
		
		НачатьТранзакцию();
		Попытка
			ТекущийОбъект.Записать();
			Объект       .Записать();
			ЗафиксироватьТранзакцию();
		Исключение
			СообщитьОбОшибке(ОписаниеОшибки());
			ОтменитьТранзакцию();
		КонецПопытки;
		Возврат;
	КонецЕсли;
	
	Запрос.Текст = 
	"ВЫБРАТЬ ПЕРВЫЕ 1
	|	Справочник.ПорядковыйНомер КАК ПорядковыйНомер,
	|	Справочник.Ссылка КАК Ссылка
	|ИЗ
	|	Справочник."+ ИмяСправочника + " КАК Справочник
	|ГДЕ
	|	Не Справочник.ПометкаУдаления";
	Если Не ТекущийЭлемент.Владелец = Неопределено Тогда
		Запрос.Текст = Запрос.Текст + "
		|	И Справочник.Владелец = &Владелец";
	КонецЕсли;
	
	Для каждого КлючИЗначение Из Новый Структура(ИмяРеквизитовРодителя) Цикл
		Запрос.Текст = Запрос.Текст + "
		|И Справочник." + КлючИЗначение.Ключ + " = &" + КлючИЗначение.Ключ;
	КонецЦикла;
	
	Запрос.Текст = Запрос.Текст + "
	|
	|УПОРЯДОЧИТЬ ПО
	|	ПорядковыйНомер" + ?(НаправлениеВверх," УБЫВ","");
	
	Результат = Запрос.Выполнить();
	
	Выборка = Результат.Выбрать();
	Если Не Выборка.Следующий() или Выборка.Ссылка = ТекущийЭлемент Тогда
		Возврат;
	КонецЕсли;
	
	ТекущийОбъект = ТекущийЭлемент.ПолучитьОбъект();
	ТекущийОбъект.ПорядковыйНомер = Выборка.ПорядковыйНомер + ?(НаправлениеВверх, 1, -1);
	Попытка
		ТекущийОбъект.Записать();
	Исключение
		СообщитьОбОшибке(ОписаниеОшибки());
	КонецПопытки; 
	
КонецПроцедуры // () 

// Функция возвращает новое значения реквизита "ПорядковыйНомер"
//
// Объект   - Тип СправочникОбъект. 
// ИмяРеквизитовРодителя - Строка, имя реквизита, в пределов которых поддерживается уникальность порядковых номеров
//
Функция ПолучитьНовыйПорядковыйНомер(Объект, ИмяРеквизитовРодителя = "Родитель")
	
	ИмяСправочника = Объект.Метаданные().Имя;
	
	Запрос = Новый Запрос;
	Запрос.Текст = "ВЫБРАТЬ ПЕРВЫЕ 1
	|	Справочник.ПорядковыйНомер КАК ПорядковыйНомер
	|ИЗ
	|	Справочник."+ ИмяСправочника + " КАК Справочник
	|ГДЕ
	|	Не Справочник.ПометкаУдаления";
	Если Не Объект.Владелец = Неопределено Тогда
		Запрос.Текст = Запрос.Текст + "
		|	И Справочник.Владелец = &Владелец";
		Запрос.УстановитьПараметр("Владелец", Объект.Владелец);
	КонецЕсли;
	
	
	Для каждого КлючИЗначение Из Новый Структура(ИмяРеквизитовРодителя) Цикл
		Запрос.Текст = Запрос.Текст + "
		|И Справочник." + КлючИЗначение.Ключ + " = &" + КлючИЗначение.Ключ;
		Запрос.УстановитьПараметр(КлючИЗначение.Ключ, Объект[КлючИЗначение.Ключ]);
	КонецЦикла;
	
	Запрос.Текст = Запрос.Текст + "
	|
	|УПОРЯДОЧИТЬ ПО
	|	ПорядковыйНомер УБЫВ";
	
	Результат = Запрос.Выполнить();
	Выборка = Результат.Выбрать();
	Если Выборка.Следующий() Тогда
		Возврат ?(ЗначениеЗаполнено(Выборка.ПорядковыйНомер), Выборка.ПорядковыйНомер, 0) + 1;
	Иначе
		Возврат 1;
	КонецЕсли; 
	
КонецФункции // ПолучитьНовыйПорядковыйНомер()

Функция ПолучитьМассивПрефиксовРИБ() Экспорт
	
	МассивПрефиксов = Новый Массив();
	
	Запрос = Новый Запрос();
	Запрос.Текст = "ВЫБРАТЬ Различные
	|	ПрефиксыИнформационныхБаз.Префикс КАК Префикс
	|ИЗ
	|	РегистрСведений.ПрефиксыИнформационныхБаз КАК ПрефиксыИнформационныхБаз";
	
	ВыборкаУзлов = Запрос.Выполнить().Выбрать();
	Пока ВыборкаУзлов.Следующий() Цикл
		
		Если Не ПустаяСтрока(ВыборкаУзлов.Префикс) Тогда
			
			МассивПрефиксов.Добавить(ВыборкаУзлов.Префикс);
			
		КонецЕсли;
		
	КонецЦикла;	
	
	Возврат МассивПрефиксов;
	
КонецФункции

Функция СформироватьМассивПрефиксовДляРИБИОрганизации(Организация) Экспорт
	
	МассивПрефиксов = ПолучитьМассивПрефиксовРИБ();	
	
	Если ЗначениеЗаполнено(Организация) Тогда
		
		Префикс = СокрЛП(Организация.Префикс);
		
		Если Префикс <> "" Тогда
			МассивПрефиксов.Добавить(Префикс);
		КонецЕсли;
		
	КонецЕсли;
	
	Если МассивПрефиксов.Количество() = 0 Тогда
		МассивПрефиксов.Добавить("");
	КонецЕсли;
	
	Возврат МассивПрефиксов;
	
КонецФункции

// Функция формирует представление заголовка документа
//
// Возвращаемое значение:
//  Строка - представление номера документа
//
Функция СформироватьЗаголовокДокумента(ДокументОбъект, НазваниеДокумента = "") Экспорт
	
	Возврат НазваниеДокумента + " № " + ПолучитьНомерНаПечать(ДокументОбъект)
	+ " от " + Формат(ДокументОбъект.Дата, "ДФ='дд ММММ гггг'")+ " г.";
	
КонецФункции // СформироватьЗаголовокДокумента()

// Процедура предназначена для преобразования номера документа.
//
// Параметры:
//  Документ - (ДокументСсылка), документ, чей номер надо получить для печати.
//
// Возвращаемое значение.
//  Строка - номер документа для печати
//
Функция ПолучитьНомерНаПечать(Документ, МассивПрефиксов = Неопределено) Экспорт
	
	Если Документ = Неопределено Тогда 
		Возврат 0;
	КонецЕсли;
	
	Номер   = СокрЛП(Документ.Номер);
	Префикс = "";
	Если МассивПрефиксов = Неопределено Тогда
		
		Организация = Неопределено;
		
		Если ТипЗнч(Документ) = Тип("ВыборкаИзРезультатаЗапроса")
			ИЛИ ТипЗнч(Документ) = Тип("Структура") Тогда
			
			Организация = Документ.Организация;
			
		Иначе
			
			Если ЕстьРеквизитОбъекта("Организация", Документ) Тогда
				
				Организация = Документ.Организация;
				
			КонецЕсли;
			
		КонецЕсли;
		
		МассивПрефиксовДляОбхода = СформироватьМассивПрефиксовДляРИБИОрганизации(Организация)
		
	Иначе
		
		МассивПрефиксовДляОбхода = МассивПрефиксов;
		
	КонецЕсли;
	
	Для Каждого ТекущийПрефикс ИЗ МассивПрефиксовДляОбхода Цикл
		
		// удаление префикса из номера документа
		Если Найти(Номер, ТекущийПрефикс)=1 Тогда 
			Номер = Сред(Номер, СтрДлина(ТекущийПрефикс)+1);
		КонецЕсли;
		
		// так же, может остаться "минус" впереди
		Если Лев(Номер, 1) = "-" Тогда
			Номер = Сред(Номер, 2);
		КонецЕсли;
		
		// удаление ведущих нулей
		Пока Лев(Номер, 1)="0" Цикл
			Номер = Сред(Номер, 2);
		КонецЦикла;
	КонецЦикла;
	
	Возврат Номер;
	
КонецФункции // ПолучитьНомерНаПечать()

// Процедура выполняет установку нового значения реквизита "ПорядковыйНомер" при необходимости
//
// Объект   - Тип СправочникОбъект. 
// ИмяРеквизитовРодителя - Строка, имя реквизита, в пределов которых поддерживается уникальность порядковых номеров
//
Процедура УстановитьНовыйПорядковыйНомерПриНеобходимости(Объект, ИмяРеквизитовРодителя = "Родитель") Экспорт
	
	Если Объект.ПометкаУдаления Тогда
		УстановитьНовоеЗначение(Объект.ПорядковыйНомер, 999999);
	Иначе
		УстанавливатьНовыйПорядковыйНомер = Объект.ПорядковыйНомер = 0 и Объект.ЭтоНовый() или Объект.ПорядковыйНомер = 999999;
		Если Не УстанавливатьНовыйПорядковыйНомер и Не Объект.ЭтоНовый() Тогда
			Для каждого КлючИЗначение Из Новый Структура(ИмяРеквизитовРодителя) Цикл
				Если Не Объект[КлючИЗначение.Ключ] = Объект.Ссылка[КлючИЗначение.Ключ] Тогда
					УстанавливатьНовыйПорядковыйНомер = Истина;
					Прервать;
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
		
		Если УстанавливатьНовыйПорядковыйНомер Тогда
			УстановитьНовоеЗначение(Объект.ПорядковыйНомер, ПолучитьНовыйПорядковыйНомер(Объект, ИмяРеквизитовРодителя));
		КонецЕсли; 
		
	КонецЕсли;
	
КонецПроцедуры //


////////////////////////////////////////////////////////////////////////////////
//
// ПРОЦЕДУРЫ - ОБРАБОТЧИКИ СОБЫТИЙ ИНТЕРФЕЙСА.

// Позволяет определить есть ли среди реквизитов шапки документа
// реквизит с переданным именем.
//
// Параметры: 
//  ИмяРеквизита - строковое имя искомого реквизита, 
//  МетаданныеДокумента - объект описания метаданных документа, среди реквизитов которого производится поиск.
//
// Возвращаемое значение:
//  Истина - нашли реквизит с таким именем, Ложь - не нашли.
//
Функция ЕстьРеквизитОбъекта(ИмяРеквизита, Объект) Экспорт
	
	Возврат НЕ (Объект=Неопределено ИЛИ Объект.Метаданные().Реквизиты.Найти(ИмяРеквизита) = Неопределено);
	
КонецФункции // ЕстьРеквизитДокумента()

// Позволяет определить есть ли среди реквизитов объекта метаданных
// реквизит с переданным именем.
//
// Параметры: 
//  ИмяРеквизита - строковое имя искомого реквизита, 
//  МетаданныеДокумента - объект описания метаданных документа, среди реквизитов которого производится поиск.
//
// Возвращаемое значение:
//  Истина - нашли реквизит с таким именем, Ложь - не нашли.
//
Функция ЕстьРеквизитОбъектаМД(ИмяРеквизита, ОбъектМД) Экспорт
	
	ЕстьРеквизит=Ложь;
	
	Для Каждого Реквизит ИЗ ОбъектМД.Реквизиты Цикл
		
		Если Реквизит.Имя=ИмяРеквизита Тогда
			
			ЕстьРеквизит=Истина;
			
			Прервать;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат ЕстьРеквизит;
	
КонецФункции // ЕстьРеквизитОбъектаМД()

////////////////////////////////////////////////////////////////////////////////
//  ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С УНИВЕРСАЛЬНЫМИ КОЛЛЕКЦИЯМИ ЗНАЧЕНИЙ

// Создает копию переданного массива, структуры или соответствия
//
// Параметры:
//  КоллекцияИсходная: тип Массив, Структура, Соответствие - исходная коллекция
// Возвращаемое значение:
//  КоллекцияКопия:  тип Массив, Структура, Соответствие - копия исходной коллекции
//
Функция СкопироватьУниверсальнуюКоллекцию(КоллекцияИсходная) Экспорт
	
	Если ТипЗнч(КоллекцияИсходная)=Тип("Массив") Тогда
		
		КоллекцияКопия=Новый Массив;
		
		Для Каждого Элемент Из КоллекцияИсходная Цикл
			
			КоллекцияКопия.Добавить(Элемент);
			
		КонецЦикла;
		
		Возврат КоллекцияКопия;
		
	ИначеЕсли ТипЗнч(КоллекцияИсходная)=Тип("Структура") Тогда
		
		КоллекцияКопия=Новый Структура;
		
		Для Каждого Элемент Из КоллекцияИсходная Цикл
			
			КоллекцияКопия.Вставить(Элемент.Ключ,Элемент.Значение);
			
		КонецЦикла;
		
		Возврат КоллекцияКопия; 
		
	ИначеЕсли ТипЗнч(КоллекцияИсходная)=Тип("Соответствие") Тогда
		
		КоллекцияКопия=Новый Соответствие;
		
		Для Каждого Элемент Из КоллекцияИсходная Цикл
			
			КоллекцияКопия.Вставить(Элемент.Ключ,Элемент.Значение);
			
		КонецЦикла;
		
		Возврат КоллекцияКопия;
		
	Иначе
		
		Сообщить("Неверный тип универсальной коллекции для копирования");
		Возврат Неопределено
		
	КонецЕсли;
	
КонецФункции // СкопироватьУниверсальнуюКоллекцию()

Функция ПолучитьЭлементСтруктурыПоИндексу(Структура,Индекс) Экспорт
	
	ТекИндекс=0;
	
	Для Каждого КлючИЗначение ИЗ Структура Цикл
		
		Если ТекИндекс=Индекс Тогда
			
			Возврат КлючИЗначение;
			
		КонецЕсли;
		
		ТекИндекс=ТекИндекс+1;
		
	КонецЦикла;
	
	Возврат Неопределено;
	
КонецФункции // ПолучитьЭлементСтруктурыПоИндексу() 

// Функция сравнивает два массива строк, полученных из одной таблицы значений, на предмет идентичности
//
//
// Параметры
//  МассивСтрок1 - МассивСтрок для сравнения
//  МассивСтрок2 - МассивСтрок для сравнения
//  ТаблицаЗначений - содержит колонки исходной ТЗ.
//
// Возвращаемое значение:
//   Булево, идентичны или нет два массива
//
Функция СравнитьМассивыСтрокТаблицыЗначений(МассивСтрок1,МассивСтрок2, ТаблицаЗначений) Экспорт
	
	Если ТипЗнч(МассивСтрок1) <> Тип("Массив") ИЛИ ТипЗнч(МассивСтрок2) <> Тип("Массив") Тогда
		Возврат Ложь;
	КонецЕсли; 
	
	Если МассивСтрок1.Количество() <> МассивСтрок2.Количество() Тогда
		Возврат Ложь;
	КонецЕсли; 
	
	Для Индекс=0 По МассивСтрок1.Количество()-1 Цикл
		
		Стр1=МассивСтрок1[Индекс];
		Стр2=МассивСтрок2[Индекс];
		
		Для каждого Колонка Из ТаблицаЗначений.Колонки Цикл
			
			Попытка
				
				Если Стр1[Колонка.Имя] <> Стр2[Колонка.Имя] Тогда
					
					Возврат Ложь;
					
				КонецЕсли;
				
			Исключение
				
				Возврат Ложь;
				
			КонецПопытки;
			
		КонецЦикла; 
		
	КонецЦикла; 
	
	Возврат Истина;
	
КонецФункции // СравнитьТаблицыЗначений()

///////////////////////////////////////////////////////////////////////////////
//
// ФУНКЦИИ ПРЕОБРАЗОВАНИЯ ИМЕН.

//Функция кэширует поля и их синонимы
Функция ПолучитьСинонимПоля(Поле) Экспорт
	
	//СтруктураВозврата = мСоответствиеПолей[Поле];
	//
	//Если СтруктураВозврата = Неопределено Тогда
	//	
	//	СтруктураВозврата = Синоним(Поле);
	//	мСоответствиеПолей.Вставить(Поле,СтруктураВозврата);
	//	
	//КонецЕсли;
	
	//Возврат СтруктураВозврата;
	Возврат Синоним(Поле);
	
КонецФункции

Функция НайтиСлово(Парам) 
	
	Возвр = "";
	ПредСимвол = "";    
	ПредВерхнийРегистр = Ложь;
	Смещение = 0;
	
	СтрДлина = СтрДлина(Парам);
	Сч = 1;
	
	Пока Сч<=СтрДлина Цикл
		
		Символ = Сред(Парам,сч,1);
		ВерхнийРегистр = (Символ = ВРег(Символ));
		
		Если Возвр = "" Тогда
			// Первый символ
			Возвр =  Символ;
		ИначеЕсли Символ = "_" Тогда
			// если разделитель то остаток должен быть без разделителя
			Смещение = 1;
			Прервать;
		ИначеЕсли КодСимвола(Символ)<58 Тогда
			// если цифра
			Если КодСимвола(ПредСимвол)<58 Тогда
				// если предыдущий символ тоже цифра - продолжаем слово
				Возвр = Возвр + Символ;
			Иначе
				Прервать;
			КонецЕсли;
		ИначеЕсли ВерхнийРегистр и НЕ ПредВерхнийРегистр или (КодСимвола(Символ)>57 и КодСимвола(ПредСимвол)<58) Тогда
			// если заглавная буква и предыдущая маленькая 
			// или буква после цифры
			Прервать;
		ИначеЕсли НЕ ВерхнийРегистр И ПредВерхнийРегистр И Сч>2 Тогда
			// если встретили маленькую после большой и это не второй символ
			Возвр = Лев(Возвр,Сч-2);
			Прервать;
		Иначе
			Возвр = Возвр + Символ;
		КонецЕсли;
		
		Сч = Сч + 1;
		
		ПредСимвол = Символ;
		ПредВерхнийРегистр = ВерхнийРегистр;
	КонецЦикла;
	
	Парам = Прав(Парам,СтрДлина - СтрДлина(Возвр)-Смещение); 
	Возврат Возвр;
	
КонецФункции

//Возвращает синоним для параметра
Функция Синоним(Парам) Экспорт
	
	Возвр = "";
	Стр = Парам;
	
	Слово = НайтиСлово(Стр);
	
	Пока Слово <> "" Цикл
		Если Возвр = "" Тогда
			// первое слово - как есть
			Возвр = Слово;
		ИначеЕсли ВРЕГ(Слово) = Слово И СтрДлина(Слово)>1 Тогда
			// если 2 и более заглавных - считаем аббревиатурой
			Возвр = Возвр + " " + Слово;
		Иначе
			// иначе - обычное слово с маленькой буквы
			Возвр = Возвр + " " + НРЕГ(Слово); 
		КонецЕсли;
		
		Слово = НайтиСлово(Стр);
	КонецЦикла;
	
	Возврат Возвр;
КонецФункции

// Функция проверяет, является ли Символ алфавитно-цифровым и если является, возвращает символ
// иначе пустой символ.
// Параметры:
//  Символ         - Строка, Символ для проверки.
// Результат:
//  Строка, Символ, если он алфавитноцифровой, иначе пустая строка.
Функция ПроверитьНаПравильностьСимвол(Символ)
	СтрокаЭталон = "АБВГДЕЁЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890";
	Возврат ?(Найти(СтрокаЭталон, ВРег(Символ)) = 0, "", Символ);
КонецФункции

// Функция формирует код на основании наименования.
//
Функция СформироватьКодНаОснованииНаименования(Вн_Наименование,Знач ДлинаКода=0,ИмяСправочника="",Владелец=Неопределено) Экспорт
	
	Наименование = Вн_Наименование;
	
	ТаблицаСлов=Новый ТаблицаЗначений;
	ТаблицаСлов.Колонки.Добавить("Слово");
	ТаблицаСлов.Колонки.Добавить("ПорядокСлова");
	ТаблицаСлов.Колонки.Добавить("ДлинаСлова");
	ТаблицаСлов.Колонки.Добавить("ЧастьСлова");
	ТаблицаСлов.Колонки.Добавить("ДлинаЧастиСлова");
	
	Если ДлинаКода=0 И ПустаяСтрока(ИмяСправочника) Тогда
		ДлинаКода=20;
	ИначеЕсли НЕ ПустаяСтрока(ИмяСправочника) Тогда
		ДлинаКода=Метаданные.Справочники[ИмяСправочника].ДлинаКода;
	КонецЕсли;
	
	ТекБуфер = "";
	ЗаполнениеСлова = Ложь;
	ПорядокСлова=1;
	
	Для Инд = 1 По СтрДлина(Наименование) Цикл
		ТекСимвол = ПроверитьНаПравильностьСимвол(Сред(Наименование, Инд, 1));
		Если ПустаяСтрока(ТекСимвол) Тогда
			Если ЗаполнениеСлова Тогда
				Если НЕ ПустаяСтрока(ТекБуфер) Тогда
					
					НоваяСтрока=ТаблицаСлов.Добавить();
					НоваяСтрока.Слово=ТекБуфер;
					НоваяСтрока.ДлинаСлова=СтрДлина(ТекБуфер);
					НоваяСтрока.ПорядокСлова=ПорядокСлова;
					
					ПорядокСлова=ПорядокСлова+1;
					
				КонецЕсли;
				ЗаполнениеСлова = Ложь;
				ТекБуфер = "";
				
			КонецЕсли;
		Иначе
			Если НЕ ЗаполнениеСлова Тогда
				ЗаполнениеСлова = Истина;
			КонецЕсли;
			
			ТекБуфер = ТекБуфер + ТекСимвол;
		КонецЕсли;
		
	КонецЦикла;
	
	Если НЕ ПустаяСтрока(ТекБуфер) Тогда
		НоваяСтрока=ТаблицаСлов.Добавить();
		НоваяСтрока.Слово=ТекБуфер;
		НоваяСтрока.ДлинаСлова=СтрДлина(ТекБуфер);
		НоваяСтрока.ПорядокСлова=ПорядокСлова;
	КонецЕсли;
	
	Если ТаблицаСлов.Количество()=0 Тогда
		Возврат "";
	КонецЕсли;
	
	СредДлина=Окр(ДлинаКода/ТаблицаСлов.Количество(),0,РежимОкругления.Окр15как10);
	ОсталосьСимволов=ДлинаКода;
	
	ТаблицаСлов.Сортировать("ДлинаСлова");
	
	Для Индекс=1 По ТаблицаСлов.Количество() Цикл
		
		ТекСлово=ТаблицаСлов[Индекс-1];
		
		Если ТекСлово.ДлинаСлова<СредДлина Тогда 	// Свободный остаток от слова, 
			//длина которых меньше текущего среднего, передается на последующие слова.
			
			ТекСлово.ЧастьСлова=ТекСлово.Слово;
			ОсталосьСимволов=ОсталосьСимволов-ТекСлово.ДлинаСлова;
			
			Если НЕ Индекс=ТаблицаСлов.Количество() Тогда
				
				СредДлина=Окр(ОсталосьСимволов/(ТаблицаСлов.Количество()-Индекс),0,РежимОкругления.Окр15как10);
				
			КонецЕсли;
			
		Иначе
			
			ТекСлово.ЧастьСлова=Лев(ТекСлово.Слово,СредДлина);
			
		КонецЕсли;
		
	КонецЦикла;
	
	ТаблицаСлов.Сортировать("ПорядокСлова");
	
	ТекКод = "";
	
	Для Каждого Слово ИЗ ТаблицаСлов Цикл
		
		ТекКод=ТекКод+ВРЕГ(ЛЕВ(Слово.ЧастьСлова,1))+Сред(Слово.ЧастьСлова,2);
		
	КонецЦикла;
	
	ПроектКода=ВернутьАлфавитноЦифровоеПредставление(ТекКод);
	
	Если ПустаяСтрока(ИмяСправочника) Тогда
		Возврат ПроектКода;
	Иначе
		Возврат ПолучитьВозможныйКодСправочника(ПроектКода,ДлинаКода,ИмяСправочника,Владелец);
	КонецЕсли;
	
КонецФункции

Функция ПолучитьВозможныйКодСправочника(ПроектКода,Знач ДлинаКода,ИмяСправочника,Владелец=Неопределено) Экспорт
	
	Если ЗначениеЗаполнено(Владелец) Тогда
		
		Если НЕ ЗначениеЗаполнено(Справочники[ИмяСправочника].НайтиПоКоду(ПроектКода,,,Владелец)) Тогда
			Возврат ПроектКода;
		КонецЕсли;
		
	Иначе
		
		Если НЕ ЗначениеЗаполнено(Справочники[ИмяСправочника].НайтиПоКоду(ПроектКода)) Тогда
			Возврат ПроектКода;
		КонецЕсли;
		
	КонецЕсли;	
	
	Если ДлинаКода=0 И ПустаяСтрока(ИмяСправочника) Тогда
		ДлинаКода=20;
	Иначе
		ДлинаКода=Метаданные.Справочники[ИмяСправочника].ДлинаКода;
	КонецЕсли;
	
	Если СтрДлина(СокрЛП(ПроектКода)) - ДлинаКода < -2 Тогда
		ТекПрефикс2 = СокрЛП(ПроектКода);
		ТекПрефикс3 = СокрЛП(ПроектКода);
		ТекПрефикс4 = СокрЛП(ПроектКода);
	Иначе
		ТекПрефикс2 = Лев(СокрЛП(ПроектКода), ДлинаКода - 2);
		ТекПрефикс3 = Лев(СокрЛП(ПроектКода), ДлинаКода - 3);
		ТекПрефикс4 = Лев(СокрЛП(ПроектКода), ДлинаКода - 4);
	КонецЕсли;
	
	Запрос = Новый Запрос;
	
	ТекстЗапроса = "ВЫБРАТЬ
	|	ТекСправочник.Код КАК Код,
	|	ВЫБОР
	|		КОГДА ТекСправочник.Код ПОДОБНО &Префикс4
	|			ТОГДА 4
	|		КОГДА ТекСправочник.Код ПОДОБНО &Префикс3
	|			ТОГДА 3
	|		ИНАЧЕ 2
	|	КОНЕЦ КАК РазрядностьНомера
	|ИЗ
	|	Справочник."+ИмяСправочника+" КАК ТекСправочник";
	
	Если ЗначениеЗаполнено(Владелец) Тогда
		
		ТекстЗапроса=ТекстЗапроса+"
		
		|ГДЕ
		|	ТекСправочник.Владелец = &Владелец
		|	И (ТекСправочник.Код ПОДОБНО &Префикс2
		|			ИЛИ ТекСправочник.Код ПОДОБНО &Префик4
		|			ИЛИ ТекСправочник.Код ПОДОБНО &Префикс3)";
		
		Запрос.УстановитьПараметр("Владелец",Владелец);
		
	Иначе
		
		ТекстЗапроса=ТекстЗапроса+"
		
		|ГДЕ
		|(ТекСправочник.Код ПОДОБНО &Префикс2
		|			ИЛИ ТекСправочник.Код ПОДОБНО &Префикс4
		|			ИЛИ ТекСправочник.Код ПОДОБНО &Префикс3)";
		
	КонецЕсли;
	
	ТекстЗапроса=ТекстЗапроса+"
	|УПОРЯДОЧИТЬ ПО
	|	РазрядностьНомера УБЫВ,
	|	Код УБЫВ";
	
	Запрос.УстановитьПараметр("Префикс2" , ТекПрефикс2 + "[0-9][0-9]%");
	Запрос.УстановитьПараметр("Префикс3" , ТекПрефикс3 + "[0-9][0-9][0-9]%");
	Запрос.УстановитьПараметр("Префикс4" , ТекПрефикс4 + "[0-9][0-9][0-9][0-9]%");
	
	Запрос.Текст=ТекстЗапроса;
	
	Результат= Запрос.Выполнить().Выбрать();
	
	Если НЕ Результат.Следующий() Тогда
		Код = ТекПрефикс2 + "01";
		Возврат Код;
	КонецЕсли;
	
	МаксЗапись  = Результат.Код;
	
	Если ЗначениеЗаполнено(МаксЗапись) Тогда
		
		ТекРазрядностьНомера=Результат.РазрядностьНомера;
		МаксЗапись    = СокрЛП(МаксЗапись);
		ЧисловаяЧасть = Прав(МаксЗапись, ТекРазрядностьНомера);
		
		Попытка
			МаксЗначение = Число(ЧисловаяЧасть);
			
			НовоеЗначение=МаксЗначение+1;
			Если НовоеЗначение>=1000 Тогда
				ТекРазрядностьНомера=4;
			ИначеЕсли НовоеЗначение>=100 Тогда
				
				ТекРазрядностьНомера=3;
				
			КонецЕсли;
			
			Код = Лев(МаксЗапись, СтрДлина(МаксЗапись) - ТекРазрядностьНомера) + СтрЗаменить(Формат(НовоеЗначение, "ЧЦ="+ТекРазрядностьНомера+"; ЧВН="), Символы.НПП, "");
		Исключение
			Код = Лев(МаксЗапись, СтрДлина(МаксЗапись) - ТекРазрядностьНомера) + ?(ТекРазрядностьНомера=2,"01",?(ТекРазрядностьНомера=3,"001","0001"));
		КонецПопытки;
		
	Иначе
		
		Код = ТекПрефикс2 + "01";
		
	КонецЕсли;
	
	Возврат Код;
	
КонецФункции // ПолучитьВозможныйКодСправочника() 
////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С ПОЧТОВЫМИ УВЕДОМЛЕНИЯМИ

// Формирует почтовый профиль по учетной записи
//
// Параметры
//  УчетнаяЗапись
//
// Возвращаемое значение:
//   ИнтернетПочтовыйПрофиль
//
Функция ПолучитьИнтернетПочтовыйПрофиль(УчетнаяЗапись) Экспорт

	Профиль = Новый ИнтернетПочтовыйПрофиль;
	
	Профиль.АдресСервераPOP3 = УчетнаяЗапись.POP3Сервер;
	Профиль.АдресСервераSMTP = УчетнаяЗапись.SMTPСервер;
	Если УчетнаяЗапись.ВремяОжиданияСервера > 0 Тогда
		Профиль.ВремяОжидания = УчетнаяЗапись.ВремяОжиданияСервера;
	КонецЕсли; 
	Профиль.Пароль           = УчетнаяЗапись.Пароль;
	Профиль.Пользователь     = УчетнаяЗапись.Пользователь;
	Профиль.ПортPOP3         = УчетнаяЗапись.ПортPOP3;
	Профиль.ПортSMTP         = УчетнаяЗапись.ПортSMTP;
	
	Если УчетнаяЗапись.ТребуетсяSMTPАутентификация Тогда
		Профиль.АутентификацияSMTP = СпособSMTPАутентификации.ПоУмолчанию;
		Профиль.ПарольSMTP         = УчетнаяЗапись.ПарольSMTP;
		Профиль.ПользовательSMTP   = УчетнаяЗапись.ПользовательSMTP;
	ИначеЕсли УчетнаяЗапись.СпособSMTPАутентификации = Перечисления.СпособыSMTPАутентификации.Login Тогда
		Профиль.АутентификацияSMTP = СпособSMTPАутентификации.Login;
		Профиль.ПарольSMTP         = УчетнаяЗапись.ПарольSMTP;
		Профиль.ПользовательSMTP   = УчетнаяЗапись.ПользовательSMTP;
	Иначе
		Профиль.АутентификацияSMTP = СпособSMTPАутентификации.БезАутентификации;
		Профиль.ПарольSMTP         = "";
		Профиль.ПользовательSMTP   = "";
	КонецЕсли; 
	
	Возврат Профиль;

КонецФункции

Процедура ОтправитьПисьмаИзРегистра() Экспорт
	
	УчетнаяЗапись = Константы.УчетнаяЗаписьДляРассылкиУведомлений.Получить();
	
	Если НЕ ЗначениеЗаполнено(УчетнаяЗапись) Тогда
		Возврат;
	КонецЕсли;
	
//	Профиль = УправлениеЭлектроннойПочтой.ПолучитьИнтернетПочтовыйПрофиль(Константы.УчетнаяЗаписьДляРассылкиУведомлений.Получить());
	Профиль = ПолучитьИнтернетПочтовыйПрофиль(Константы.УчетнаяЗаписьДляРассылкиУведомлений.Получить());
	Почта   = Новый ИнтернетПочта;
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
	"ВЫБРАТЬ
	|	УведомленияПоЭлектроннойПочте.Источник,
	|	УведомленияПоЭлектроннойПочте.ДатаСоздания,
	//|	УведомленияПоЭлектроннойПочте.НомерЛистаХранимогоФайла,
	|	УведомленияПоЭлектроннойПочте.Письмо
	|ИЗ
	|	РегистрСведений.УведомленияПоЭлектроннойПочте КАК УведомленияПоЭлектроннойПочте
	|ГДЕ
	|	УведомленияПоЭлектроннойПочте.ДатаОтправки = &ПустаяДата";
	
	Запрос.УстановитьПараметр("ПустаяДата", ПустоеЗначениеТипа(Тип("Дата")));
	Выборка = Запрос.Выполнить().Выбрать();
	//Профиль.АутентификацияSMTP = СпособSMTPАутентификации.БезАутентификации; 
	Почта.Подключиться(Профиль);
	
	КоличествоИсключений = 0;
	ПроизошлоИсключение = Ложь;
	Пока Выборка.Следующий() И КоличествоИсключений < 7 Цикл
		Если ПроизошлоИсключение Тогда
			Почта.Подключиться(Профиль);  
			ПроизошлоИсключение = Ложь;	
		КонецЕсли;	
		Попытка
			Письмо = Выборка.Письмо.Получить();
			Письмо.Отправитель = УчетнаяЗапись.АдресЭлектроннойПочты;
			Почта.Послать(Письмо);
		Исключение
			ПроизошлоИсключение = Истина;
			КоличествоИсключений = КоличествоИсключений + 1;
			ИнформацияОбОшибке = ИнформацияОбОшибке();
			ПричинаОписание = ИнформацияОбОшибке.Причина.Описание;
			
			// когда неверный адрес получателя
			Если Найти(ПричинаОписание, "Bad recipient address syntax")>0 Тогда // SMTP error 5.3.1
				СтрокаПолучатели = "";
				Для Каждого Получатель Из Письмо.Получатели Цикл
					СтрокаПолучатели = СтрокаПолучатели + ", " + Получатель.Адрес;
				КонецЦикла;
				ПричинаОписание = ПричинаОписание + "получатели: " + Сред(СтрокаПолучатели, 3);
				ИзменитьСтатусУведомления(Выборка, Письмо, Истина);
			ИначеЕсли Найти(ПричинаОписание, "Client host rejected")>0 Тогда // SMTP error 4.7.1
				СообщитьОбОшибке(ИнформацияОбОшибке.Описание+ " по причине: "+ПричинаОписание);
				Прервать;
			КонецЕсли;
			
			СообщитьОбОшибке(ИнформацияОбОшибке.Описание+ " по причине: "+ПричинаОписание);
			Продолжить;
		КонецПопытки;
		
		ИзменитьСтатусУведомления(Выборка, Письмо);
	КонецЦикла;
	Почта.Отключиться();
		
КонецПроцедуры

Процедура ИзменитьСтатусУведомления(Выборка, Письмо, ОшибкаВАдресеПолучателя=Ложь)
	
	МенеджерЗаписи = РегистрыСведений.УведомленияПоЭлектроннойПочте.СоздатьМенеджерЗаписи();
	Если Письмо.Вложения.Количество() > 0 Тогда
		МенеджерЗаписи.Источник     = Выборка.Источник;
		МенеджерЗаписи.ДатаСоздания = Выборка.ДатаСоздания;
//		МенеджерЗаписи.НомерЛистаХранимогоФайла = Выборка.НомерЛистаХранимогоФайла;
		МенеджерЗаписи.Письмо       = Новый ХранилищеЗначения(Письмо);
		МенеджерЗаписи.ДатаОтправки = ПолучитьОперативнуюОтметкуВремени(); 
//		МенеджерЗаписи.ОшибкаВАдресеПолучателя = ОшибкаВАдресеПолучателя; 		
		МенеджерЗаписи.Записать();	
	КонецЕсли;
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ РАБОТЫ С КРИТЕРИЯМИ ОТБОРА

// Функция разбирает строку вида
// ТипОбъектаМетаданных.ИмяДокумента.ТабличнаяЧасть.ИмяТабличнойЧасти.Реквизит.ИмяРеквизита.
// ТипОбъектаМетаданных должен быть Справочник или Документ.
//
// Параметры:
//  ПутьКДанным - строка.
//  МетаданныеОбъекта - Объект метаданных
//
// Возвращаемое значение:
//  Структура - путь к объекту метаданных
//
Функция РазобратьПутьКОбъектуМетаданных(ПутьКДанным, МетаданныеОбъекта = Неопределено) Экспорт
	
	Структура = Новый Структура;
	
	СоответствиеИмен = Новый Массив();
	СоответствиеИмен.Добавить("ТипОбъекта");
	СоответствиеИмен.Добавить("ВидОбъекта");
	СоответствиеИмен.Добавить("ПутьКДанным");
	СоответствиеИмен.Добавить("ИмяТаблЧасти");
	СоответствиеИмен.Добавить("ИмяРеквизита");
	
	Для индекс = 1 по 3 Цикл
		
		Точка = Найти(ПутьКДанным, ".");
		ТекущееЗначение = Лев(ПутьКДанным, Точка-1);
		Структура.Вставить(СоответствиеИмен[индекс-1], ТекущееЗначение);
		ПутьКДанным = Сред(ПутьКДанным, Точка+1);
		
	КонецЦикла;
	
	ПутьКДанным = СтрЗаменить(ПутьКДанным, "Реквизит.", "");
	
	Если Структура.ПутьКДанным = "ТабличнаяЧасть" Тогда
		
		Для индекс = 4 по 5  Цикл 
			
			Точка = Найти(ПутьКДанным, ".");
			Если Точка = 0 Тогда
				ТекущееЗначение = ПутьКДанным;
			Иначе
				ТекущееЗначение = Лев(ПутьКДанным, Точка-1);
			КонецЕсли;
			
			Структура.Вставить(СоответствиеИмен[индекс-1], ТекущееЗначение);
			ПутьКДанным = Сред(ПутьКДанным,  Точка+1);
			
		КонецЦикла;
		
	Иначе
		
		Структура.Вставить(СоответствиеИмен[3], "");
		Структура.Вставить(СоответствиеИмен[4], ПутьКДанным);
		
	КонецЕсли;
	
	Если МетаданныеОбъекта <> Неопределено Тогда
		Структура.Вставить("Метаданные", МетаданныеОбъекта);
	Иначе
		Если Структура.ТипОбъекта = "Документ" Тогда
			Структура.Вставить("Метаданные", Метаданные.Документы[Структура.ВидОбъекта]);
		Иначе
			Структура.Вставить("Метаданные", Метаданные.Справочники[Структура.ВидОбъекта]);
		КонецЕсли;
	КонецЕсли;
	
	Возврат Структура;
	
КонецФункции // РазобратьПутьКОбъектуМетаданных()

/////////////////////////////////////////////////////////////////////////////////////////
/////// СТАТИСТИЧЕСКИЕ ПРОЦЕДУРЫ И ФУНКЦИИ
////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ОБНОВЛЕНИЯ КОНФИГУРАЦИИ

////////////////////////////////////////////////////////////////////////////////
// СИСТЕМНЫЕ ПРОЦЕДУРЫ И ФУНКЦИИ 

////////////////////////////////////////////////////////////////////////////////
// Общие процедуры и функции 

// Функция возвращает ссылку на текущего пользователя базы данных,
// установленного по учетной записи пользователя конфигурации.
//
// Возвращаемое значение:
//  СправочникСсылка.Пользователи
//
Функция ТекущийПользователь() Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	Возврат Пользователи.ТекущийПользователь();
	
КонецФункции 

// Функция ПолучитьЗначенияРеквизитов возвращает структуру,
// содержащую значения реквизитов прочитанные из информационной базы
// по ссылке на объект.
// 
//  Если доступа к одному из реквизитов нет, возникнет исключение прав доступа.
//  Если необходимо зачитать реквизит независимо от прав текущего пользователя,
//  то следует использовать предварительный переход в привилегированный режим.
// 
// Параметры:
//  Ссылка       - ссылка на объект, - элемент справочника, документ, ...
//  ИменаРеквизитов - Строка, имена реквизитов перечисленные через запятую,
//               в формате требований к свойствам структуры.
//               Например, "Код, Наименование, Родитель".
// 
// Возвращаемое значение:
//  Структура    - содержит список свойств, как список имен в строке
//                 ИменаРеквизитов, со значениям реквизитов, прочитанных
//                 из информационной базы.
// 
Функция ПолучитьЗначенияРеквизитов(Ссылка, ИменаРеквизитов) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.Текст =
		"ВЫБРАТЬ
		|	" + ИменаРеквизитов + "
		|ИЗ
		|	" + Ссылка.Метаданные().ПолноеИмя() + " КАК Таблица
		|ГДЕ
		|	Таблица.Ссылка = &Ссылка";
	Запрос.УстановитьПараметр("Ссылка", Ссылка);
	
	Выборка = Запрос.Выполнить().Выбрать();
	Выборка.Следующий();
	Результат = Новый Структура(ИменаРеквизитов);
	ЗаполнитьЗначенияСвойств(Результат, Выборка);
	
	Возврат Результат;
	
КонецФункции

// Функция ПолучитьЗначениеРеквизита возвращает значение
// реквизита, прочитанного из информационной базы по ссылке на объект.
// 
//  Если доступа к реквизиту нет, возникнет исключение прав доступа.
//  Если необходимо зачитать реквизит независимо от прав текущего пользователя,
//  то следует использовать предварительный переход в привилегированный режим.
// 
// Параметры:
//  Ссылка       - ссылка на объект, - элемент справочника, документ, ...
//  ИмяРеквизита - Строка, например, "Код".
// 
// Возвращаемое значение:
//  Произвольный    - зависит от типа значения прочитанного реквизита.
// 
Функция ПолучитьЗначениеРеквизита(Ссылка, ИмяРеквизита) Экспорт
	
	Результат = ПолучитьЗначенияРеквизитов(Ссылка, ИмяРеквизита);
	Возврат Результат[ИмяРеквизита];
	
КонецФункции 

////////////////////////////////////////////////////////////////////////////////
// Вспомогательные процедуры и функции

// Функция ИнформационнаяБазаФайловая определяет режим эксплуатации
// информационной базы файловый (Истина) или Серверный (Ложь).
//  При проверке используется СтрокаСоединенияИнформационнойБазы, которую
// можно указать явно.
//
// Параметры:
//  СтрокаСоединенияИнформационнойБазы - Строка - параметр используется, если
//                 нужно проверить строку соединения не текущей информационной базы.
//
// Возвращаемое значение:
//  Булево.
//
Функция ИнформационнаяБазаФайловая(Знач СтрокаСоединенияИнформационнойБазы = "") Экспорт
			
	Если ПустаяСтрока(СтрокаСоединенияИнформационнойБазы) Тогда
		СтрокаСоединенияИнформационнойБазы =  СтрокаСоединенияИнформационнойБазы();
	КонецЕсли;
	Возврат Найти(Врег(СтрокаСоединенияИнформационнойБазы), "FILE=") = 1;
	
КонецФункции 

// Функция ПрочитатьXMLВТаблицу преобразует текст формата XML в таблицу значений,
// при этом колонки таблицы формируются на основе описания в XML.
//
// Параметры:
//  ТекстXML     - текст формата XML.
//
// Возвращаемое значение:
//  ТаблицаЗначений.
//
Функция ПрочитатьXMLВТаблицу(ТекстXML) Экспорт
	
	Чтение = Новый ЧтениеXML;
	Чтение.УстановитьСтроку(ТекстXML);
	
	// Прочитаем первый узел и проверим его
	Если Не Чтение.Прочитать() Тогда
		ВызватьИсключение("Пустой XML");
	ИначеЕсли Чтение.Имя <> "Items" Тогда
		ВызватьИсключение("Ошибка в структуре XML");
	КонецЕсли;
	
	// Получим описание таблицы и создадим ее
	ИмяТаблицы = Чтение.ПолучитьАтрибут("Description");
	ИменаКолонок = СтрЗаменить(Чтение.ПолучитьАтрибут("Columns"), ",", Символы.ПС);
	Колонок = СтрЧислоСтрок(ИменаКолонок);
	
	ТаблицаЗначений = Новый ТаблицаЗначений;
	Для Сч = 1 По Колонок Цикл
		ТаблицаЗначений.Колонки.Добавить(СтрПолучитьСтроку(ИменаКолонок, Сч), Новый ОписаниеТипов("Строка"));
	КонецЦикла;
	
	// Заполним значения в таблице
	Пока Чтение.Прочитать() Цикл
		
		Если Чтение.ТипУзла <> ТипУзлаXML.НачалоЭлемента Тогда
			Продолжить;
		ИначеЕсли Чтение.Имя <> "Item" Тогда
			ВызватьИсключение("Ошибка в структуре XML");
		КонецЕсли;
		
		новСтр = ТаблицаЗначений.Добавить();
		Для Сч = 1 По Колонок Цикл
			ИмяКолонки = СтрПолучитьСтроку(ИменаКолонок, Сч);
			новСтр[Сч-1] = Чтение.ПолучитьАтрибут(ИмяКолонки);
		КонецЦикла;
		
	КонецЦикла;
	
	// Заполним результат
	Результат = Новый Структура;
	Результат.Вставить("ИмяТаблицы", ИмяТаблицы);
	Результат.Вставить("Данные", ТаблицаЗначений);
	
	Возврат Результат;
	
КонецФункции // ПрочитатьXMLВТаблицу()

// Функция СохранитьФайлНаСервере перемещает двоичные данные из временного
// хранилища в файл на сервере (данные во временном хранилище удаляются).
//
// Параметры:
//  АдресВоВременномХранилище - адрес, указывающий на значение во временном хранилище.
//  ИмяФайла     - Строка, необязательный параметр,
//                 полное имя файла на сервере для сохранения двоичных данных.
//
// Возвращаемое значение:
//  Строка       - полное имя файла на сервере, в который сохранены двоичные данные.
//
Функция СохранитьФайлНаСервере(Знач АдресВоВременномХранилище, Знач ИмяФайла = Неопределено) Экспорт
	
	Если ИмяФайла = Неопределено Тогда
		ИмяФайла = ПолучитьИмяВременногоФайла();
	КонецЕсли;
	
	ДвоичныеДанные = ПолучитьИзВременногоХранилища(АдресВоВременномХранилище);
	ДвоичныеДанные.Записать(ИмяФайла);
	
	УдалитьИзВременногоХранилища(АдресВоВременномХранилище);
	
	Возврат ИмяФайла;
	
КонецФункции // СохранитьФайлНаСервере()


////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ РАБОТЫ С ГЛОБАЛЬНЫМИ ПЕРЕМЕННЫМИ

Функция ПолучитьЗначениеПеременной(ИмяПараметра, Кэш = Неопределено, КэшИзменен = Ложь) Экспорт
	
	Если Кэш = Неопределено Тогда
		// Кэш не был проинициализирован
		Кэш = Новый Структура;
	Иначе
		// Ищем значение в структуре
		НайденноеЗначение = Неопределено;
		Если Кэш.Свойство(ИмяПараметра, НайденноеЗначение) Тогда
			Возврат НайденноеЗначение;
		КонецЕсли;
	КонецЕсли;
	
	// Значение в КЭШе не нашли, получим значение из БД
	Если ВРег(ИмяПараметра) = ВРег("глТекущийПользователь") Тогда
		НайденноеЗначение = Пользователи.ТекущийПользователь();
		
	ИначеЕсли ВРег(ИмяПараметра) = ВРег("глТаблицаЯзыков") Тогда
		
	ИначеЕсли ВРег(ИмяПараметра) = ВРег("КоличествоПараллельныхПотоков") Тогда
		НайденноеЗначение = Константы.КоличествоПараллельныхПотоков.Получить();
	Иначе
		СтрокаИсключения = "Невозможно обработать параметр " + """" + ИмяПараметра + """" + " для получения значения";
		ВызватьИсключение СтрокаИсключения;
	КонецЕсли;
	
	Кэш.Вставить(ИмяПараметра, НайденноеЗначение);
	КэшИзменен = Истина;
	
	Возврат НайденноеЗначение;
	
КонецФункции

// Анализирует строку Стр на наличие в ней символов - не цифр,кроме "." и ","
// Возвращает Истина, если в строке присутствуют символы, не являющиеся цифрами.
// В противном случае возвращает Ложь.
//
Функция ЕстьНеЦифрыВСтрокеБезТочкиИЗапятой(Знач Стр) Экспорт
		
	КодСимвола0 = КодСимвола("0");
	КодСимвола9 = КодСимвола("9");
	КодСимволаЗапятая = КодСимвола(",");
	КодСимволаТочка = КодСимвола(".");
	
	Для Инд = 1 По СтрДлина(Стр) Цикл 
		Если КодСимвола(Стр, Инд) = КодСимволаЗапятая ИЛИ КодСимвола(Стр, Инд) = КодСимволаТочка Тогда
			Продолжить;
		КонецЕсли;
		Если НЕ (КодСимвола(Стр, Инд) >= КодСимвола0 И КодСимвола(Стр, Инд) <= КодСимвола9) Тогда
			Возврат Истина;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Ложь;
	
КонецФункции

Функция ПроверитьЗначениеНаПризнакТипа(Знач Значение) Экспорт
	
	Значение = СтрЗаменить(Значение,"_Строка",""); 
	
	Возврат Значение;	
КонецФункции

// Процедура - Сообщить
//
// Параметры:
//  ИдентификаторНазначения	 - 	 - 
//  КлючДанных				 - 	 - 
//  Поле					 - 	 - 
//  ПутьКДанным				 - 	 - 
//  Текст					 - 	 - 
//
Процедура СообщитьПользователю(ИдентификаторНазначения = Неопределено, КлючДанных = Неопределено, Поле = Неопределено, ПутьКДанным = Неопределено, Текст) Экспорт
	
	Сообщение = Новый СообщениеПользователю;
	Если ИдентификаторНазначения <> Неопределено Тогда
		Сообщение.ИдентификаторНазначения = ИдентификаторНазначения;
	КонецЕсли;
	Если КлючДанных <> Неопределено И ПутьКДанным = Неопределено Тогда
		Сообщение.УстановитьДанные(КлючДанных);
	ИначеЕсли КлючДанных <> Неопределено И ПутьКДанным <> Неопределено Тогда
		Сообщение.КлючДанных = КлючДанных;
		Сообщение.ПутьКДанным = ПутьКДанным;
	КонецЕсли;
	Если Поле <> Неопределено Тогда
		Сообщение.Поле = Поле;
	КонецЕсли;
	Сообщение.Текст = Текст;
	Сообщение.Сообщить();
	
КонецПроцедуры

// Выводит сообщение об ошибке и выставляет параметр Отказ в "Истина". 
// В случае работы на клиенте или на сервере выводит в окно сообщений,
// в случае внешнего соединения вызывает исключение.
//
// Параметры:
//  ТекстСообщения - строка, текст сообщения.
//  Отказ          - булево, признак отказа (необязательный).
//
Процедура СообщитьОбОшибке(Знач ТекстСообщения, Отказ = Ложь, Заголовок = "", Знач Статус = Неопределено) Экспорт
	
	Если Статус = Неопределено Тогда
		Статус = СтатусСообщения.Важное;
	КонецЕсли;
	
	ТекстСообщения = СформироватьТекстСообщения(ТекстСообщения);
	Отказ = Истина;
	
	#Если ВнешнееСоединение Тогда
		
		Если ЗначениеЗаполнено(Заголовок) Тогда
			ТекстСообщения = Заголовок + Символы.ПС + ТекстСообщения;
			Заголовок = "";
		КонецЕсли;
		
		ВызватьИсключение (ТекстСообщения);
	#ИначеЕсли ТолстыйКлиентОбычноеПриложение Тогда
		ОбработкаОповещения = глЗначениеПеременной("глОбработкаСообщений");
		Если Статус = СтатусСообщения.ОченьВажное Тогда
			ВидСообщения = Перечисления.ВидыСообщений.Ошибка;
		ИначеЕсли Статус = СтатусСообщения.Важное Тогда
			ВидСообщения = Перечисления.ВидыСообщений.ВажнаяИнформация;
		Иначе
			ВидСообщения        = Перечисления.ВидыСообщений.Информация;
		КонецЕсли;
		
		Если ЗначениеЗаполнено(Заголовок) Тогда
			РодительскаяСтрока = ОбработкаОповещения.ДобавитьСообщение(Заголовок, ВидСообщения);
		Иначе
			РодительскаяСтрока = Неопределено;
		КонецЕсли;
		
		ОбработкаОповещения.ДобавитьСообщение(ТекстСообщения, ВидСообщения, , РодительскаяСтрока);
		ОбработкаОповещения.ПоказатьСообщения();
	#Иначе
		
		Сообщить(ТекстСообщения, Статус);
		
	#КонецЕсли
	
КонецПроцедуры // СообщитьОбОшибке()

Функция СравнитьСтруктурыЗначений(Структура1, Структура2) Экспорт
	
	Если НЕ Структура1.Количество()=Структура2.Количество() Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если НЕ ТипЗнч(Структура1)=ТипЗнч(Структура2) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Для Каждого Элемент ИЗ Структура1 Цикл
		
		Если Не Структура2.Свойство(Элемент.Ключ) Тогда
			Возврат Ложь;
		ИначеЕсли НЕ ТипЗнч(Элемент.Значение)=ТипЗнч(Структура2[Элемент.Ключ]) Тогда
			Возврат Ложь;
		ИначеЕсли ТипЗнч(Элемент.Значение)=Тип("Структура") Тогда
			Если НЕ СравнитьСтруктурыЗначений(Элемент.Значение,Структура2[Элемент.Ключ]) Тогда
				Возврат Ложь;
			КонецЕсли;
		ИначеЕсли ТипЗнч(Элемент.Значение)=Тип("СписокЗначений") Тогда
			Если НЕ СравнитьСпискиЗначений(Элемент.Значение,Структура2[Элемент.Ключ]) Тогда
				Возврат Ложь;
			КонецЕсли;
		ИначеЕсли ТипЗнч(Элемент.Значение)=Тип("Массив") Тогда
			Если НЕ СравнитьМассивыЗначений(Элемент.Значение,Структура2[Элемент.Ключ]) Тогда
				Возврат Ложь;
			КонецЕсли;
		ИначеЕсли НЕ Элемент.Значение=Структура2[Элемент.Ключ] Тогда
			Возврат Ложь;
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Истина;
	
КонецФункции //  СравнитьСтруктурыЗначений()

Функция СравнитьМассивыЗначений(Массив1,Массив2)
	
	Если НЕ Массив1.Количество()=Массив2.Количество() Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если НЕ ТипЗнч(Массив1)=ТипЗнч(Массив2) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Для Индекс=0 По Массив1.Количество()-1 Цикл
		
		Значение1=Массив1[Индекс];
		Значение2=Массив2[Индекс];
		
		Если НЕ ТипЗнч(Значение1)=ТипЗнч(Значение2) Тогда
			Возврат Ложь;
		ИначеЕсли ТипЗнч(Значение1)=Тип("Структура") Тогда 
			Если НЕ СравнитьСтруктурыЗначений(Значение1,Значение2) Тогда
				Возврат Ложь;
			КонецЕсли;
		ИначеЕсли ТипЗнч(Значение1)=Тип("СписокЗначений") Тогда
			Если НЕ СравнитьСпискиЗначений(Значение1,Значение2) Тогда
				Возврат Ложь;
			КонецЕсли;
		ИначеЕсли ТипЗнч(Значение1)=Тип("Массив") Тогда 
			Если НЕ СравнитьМассивыЗначений(Значение1,Значение2) Тогда
				Возврат Ложь;
			КонецЕсли;
		ИначеЕсли НЕ Значение1=Значение2 Тогда
			Возврат Ложь;
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Истина;	
	
КонецФункции // СравнитьМассивыЗначений() 

Функция СравнитьСпискиЗначений(Список1,Список2) Экспорт
	
	Если НЕ Список1.Количество()=Список2.Количество() Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если НЕ ТипЗнч(Список1)=ТипЗнч(Список2) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Для Индекс=0 По Список1.Количество()-1 Цикл
		
		Значение1=Список1[Индекс].Значение;
		Значение2=Список2[Индекс].Значение;
		
		Если НЕ ТипЗнч(Значение1)=ТипЗнч(Значение2) Тогда
			Возврат Ложь;
		ИначеЕсли ТипЗнч(Значение1)=Тип("Структура") Тогда 
			Если НЕ СравнитьСтруктурыЗначений(Значение1,Значение2) Тогда
				Возврат Ложь;
			КонецЕсли;
		ИначеЕсли ТипЗнч(Значение1)=Тип("СписокЗначений") Тогда
			Если НЕ СравнитьСпискиЗначений(Значение1,Значение2) Тогда
				Возврат Ложь;
			КонецЕсли;
		ИначеЕсли ТипЗнч(Значение1)=Тип("Массив") Тогда
			Если НЕ СравнитьМассивыЗначений(Значение1,Значение2) Тогда
				Возврат Ложь;
			КонецЕсли;
		ИначеЕсли НЕ Значение1=Значение2 Тогда
			Возврат Ложь;
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Истина;	
	
КонецФункции // СравнитьСписокыЗначений()

Функция МинимальноеЗначение(МассивЗначений) Экспорт
	
	Если МассивЗначений.Количество()=0 Тогда
		Возврат 0;
	КонецЕсли;
	
	ТекМинимум=МассивЗначений[0];
	
	Для Каждого Значение ИЗ МассивЗначений Цикл
		
		Если Значение<ТекМинимум Тогда
			
			ТекМинимум=Значение;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат ТекМинимум;
	
КонецФункции // МинимальноеЗначение()

Функция МаксимальноеЗначение(МассивЗначений) Экспорт
	
	Если МассивЗначений.Количество()=0 Тогда
		Возврат 0;
	КонецЕсли;
	
	ТекМаксимум=МассивЗначений[0];
	
	Для Каждого Значение ИЗ МассивЗначений Цикл
		
		Если Значение>ТекМаксимум Тогда
			
			ТекМаксимум=Значение;
			
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат ТекМаксимум;
	
КонецФункции // МаксимальноеЗначение()

// Функция убирает из текста сообщения служебную информацию
//
// Параметры
//  ТекстСообщения, Строка, исходный текст сообщения//
// Возвращаемое значение:
//   Строка
//
Функция СформироватьТекстСообщения(Знач ТекстСообщения) Экспорт
	
	НачалоСлужебногоСообщения    = Найти(ТекстСообщения, "{");
	ОкончаниеСлужебногоСообщения = Найти(ТекстСообщения, "}:");
	
	Если ОкончаниеСлужебногоСообщения > 0 
		И НачалоСлужебногоСообщения > 0 
		И НачалоСлужебногоСообщения < ОкончаниеСлужебногоСообщения Тогда
		
		ТекстСообщения = Лев(ТекстСообщения, (НачалоСлужебногоСообщения - 1)) +
		Сред(ТекстСообщения, (ОкончаниеСлужебногоСообщения + 2));
		
	КонецЕсли;
	
	Возврат СокрЛП(ТекстСообщения);
	
КонецФункции // ()

Функция ПолучитьКоличествоСвойств() Экспорт

//	Возврат Константы.КоличествоСвойствЗначенийАналитик.Получить();
	Возврат 5;
	
КонецФункции	

Функция ПолучитьНастройкиПоУмолчанию(СтруктураПараметров) Экспорт
	
	Модель 				= СтруктураПараметров.Модель;
	РеквизитыДокумента 	= СтруктураПараметров.РеквизитыДокумента;  
	
	Запрос = Новый Запрос;
	Запрос.Текст = "
	
	|ВЫБРАТЬ
	|	ЭД_Модель.Ссылка КАК Модель,
	|	ЕСТЬNULL(ЭД_МодельРеквизитыДокумента.Реквизит, ЗНАЧЕНИЕ(Справочник.ЭД_Аналитики.ПустаяСсылка)) КАК Реквизит,
	|	ЕСТЬNULL(ЭД_МодельРеквизитыДокумента.ПриоритетДляНастроек, 0) КАК ПриоритетДляНастроек
	|ИЗ
	|	Справочник.ЭД_Модель КАК ЭД_Модель
	|		ЛЕВОЕ СОЕДИНЕНИЕ Справочник.ЭД_Модель.РеквизитыДокумента КАК ЭД_МодельРеквизитыДокумента
	|		ПО ЭД_МодельРеквизитыДокумента.Ссылка = ЭД_Модель.Ссылка
	|			И ЭД_МодельРеквизитыДокумента.Реквизит В (&Реквизиты)
	|ГДЕ
	|	ЭД_Модель.Ссылка = &Модель	   
	|
	|УПОРЯДОЧИТЬ ПО
	|	ПриоритетДляНастроек
	|";
	
	Запрос.УстановитьПараметр("Модель", 	СтруктураПараметров.Модель);
	Запрос.УстановитьПараметр("Реквизиты", 	РеквизитыДокумента.ВыгрузитьКолонку("Реквизит"));
	
	РезультатЗапроса = Запрос.Выполнить();
	
	тзНастройкиМодели = РезультатЗапроса.Выгрузить();
	
	ТекстЗапроса = "";
	
	Запрос = Новый Запрос;
	Запрос.УстановитьПараметр("Модель",	СтруктураПараметров.Модель);
	
	ТекстЗапроса = ТекстЗапроса + "
	|ВЫБРАТЬ
	|	ЭД_Модель.Ссылка КАК Модель
	|ПОМЕСТИТЬ втМодель
	|ИЗ
	|	Справочник.ЭД_Модель КАК ЭД_Модель
	|ГДЕ
	|	ЭД_Модель.Ссылка = &Модель
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ РАЗЛИЧНЫЕ
	|	ЭД_НастройкиПоУмолчанию.Модель КАК Модель,
	|	ЭД_НастройкиПоУмолчанию.ИдентификаторСтроки КАК ИдентификаторСтроки,
	|	ЭД_НастройкиПоУмолчанию.НастройкаОтображения КАК НастройкаОтображения,
	|	ЭД_НастройкиПоУмолчанию.НастройкаПравилаПроверки КАК НастройкаПравилаПроверки,
	|	ЭД_НастройкиПоУмолчанию.НастройкаМакетаИмпорта КАК НастройкаМакетаИмпорта,
	|	ЭД_НастройкиПоУмолчанию.НастройкаРасчета КАК НастройкаРасчета
	|ПОМЕСТИТЬ втНастройкиПоУмолчаниюНомераСтрок
	|ИЗ
	|	РегистрСведений.ЭД_НастройкиПоУмолчанию КАК ЭД_НастройкиПоУмолчанию
	|ГДЕ
	|	ЭД_НастройкиПоУмолчанию.Модель = &Модель
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	втМодель.Модель КАК Модель,
	|	ЕСТЬNULL(втНастройкиПоУмолчаниюНомераСтрок.ИдентификаторСтроки, 0) КАК ИдентификаторСтроки,
	|	ЕСТЬNULL(втНастройкиПоУмолчаниюНомераСтрок.НастройкаОтображения, ЗНАЧЕНИЕ(Справочник.ЭД_НастройкиОтображения.ПустаяСсылка)) КАК НастройкаОтображения,
	|	ЕСТЬNULL(втНастройкиПоУмолчаниюНомераСтрок.НастройкаПравилаПроверки, ЗНАЧЕНИЕ(Справочник.ЭД_ПравилаПроверки.ПустаяСсылка)) КАК НастройкаПравилаПроверки,
	|	ЕСТЬNULL(втНастройкиПоУмолчаниюНомераСтрок.НастройкаМакетаИмпорта, ЗНАЧЕНИЕ(Справочник.ЭД_МакетыИмпорта.ПустаяСсылка)) КАК НастройкаМакетаИмпорта,
	|	ЕСТЬNULL(втНастройкиПоУмолчаниюНомераСтрок.НастройкаРасчета, ЗНАЧЕНИЕ(Справочник.ЭД_НастройкиРасчетов.ПустаяСсылка)) КАК НастройкаРасчета
	|ПОМЕСТИТЬ втМодельНомераСтрок
	|ИЗ
	|	втМодель КАК втМодель
	|		ЛЕВОЕ СОЕДИНЕНИЕ втНастройкиПоУмолчаниюНомераСтрок КАК втНастройкиПоУмолчаниюНомераСтрок
	|		ПО втМодель.Модель = втНастройкиПоУмолчаниюНомераСтрок.Модель
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	ЭД_НастройкиПоУмолчанию.Модель КАК Модель,
	|	ЭД_НастройкиПоУмолчанию.ИдентификаторСтроки КАК ИдентификаторСтроки,
	|	ЭД_НастройкиПоУмолчанию.Реквизит КАК Реквизит,
	|	ЭД_НастройкиПоУмолчанию.ЗначениеРеквизита КАК ЗначениеРеквизита,
	|	ЭД_НастройкиПоУмолчанию.ТипРеквизита КАК ТипРеквизита
	|ПОМЕСТИТЬ втНастройкиПоУмолчанию
	|ИЗ
	|	РегистрСведений.ЭД_НастройкиПоУмолчанию КАК ЭД_НастройкиПоУмолчанию
	|ГДЕ
	|	ЭД_НастройкиПоУмолчанию.Модель = &Модель
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	втМодельНомераСтрок.Модель КАК Модель,
	|	втМодельНомераСтрок.ИдентификаторСтроки КАК ИдентификаторСтроки,
	|	втМодельНомераСтрок.НастройкаОтображения КАК НастройкаОтображения,
	|	втМодельНомераСтрок.НастройкаПравилаПроверки КАК НастройкаПравилаПроверки,
	|	втМодельНомераСтрок.НастройкаМакетаИмпорта КАК НастройкаМакетаИмпорта,
	|	втМодельНомераСтрок.НастройкаРасчета КАК НастройкаРасчета
	|";
	
	
	
	
	Для Ин = 1 По тзНастройкиМодели.Количество() Цикл
		ТекстЗапроса = ТекстЗапроса +  ",
		|втНастройкиПоУмолчанию" + Ин + ".ЗначениеРеквизита КАК ЗначениеРеквизита" + Ин + ",
		|ВЫБОР
		|	КОГДА втНастройкиПоУмолчанию" + Ин + ".ЗначениеРеквизита = ЗНАЧЕНИЕ(Справочник.ЭД_ЗначенияАналитик.ПустаяСсылка)
		|		ТОГДА 2
		|	ИНАЧЕ 1
		|КОНЕЦ КАК Приоритет" + Ин + "
		|";
		
	КонецЦикла;
	
	ТекстЗапроса = ТекстЗапроса +  "
	|ПОМЕСТИТЬ втНастройки
	|ИЗ
	|	втМодельНомераСтрок КАК втМодельНомераСтрок
	|";
	
	
	Для Ин = 1 По тзНастройкиМодели.Количество() Цикл
		
		ТекСтрока = тзНастройкиМодели[Ин - 1];
		
		ТекстЗапроса = ТекстЗапроса +  "
		|
		|ЛЕВОЕ СОЕДИНЕНИЕ втНастройкиПоУмолчанию КАК втНастройкиПоУмолчанию" + Ин + "
		|ПО втМодельНомераСтрок.Модель = втНастройкиПоУмолчанию" + Ин + ".Модель
		|	И втМодельНомераСтрок.ИдентификаторСтроки = втНастройкиПоУмолчанию" + Ин + ".ИдентификаторСтроки
		|	И (втНастройкиПоУмолчанию" + Ин + ".Реквизит = &Реквизит" + Ин + ")
		|	И (втНастройкиПоУмолчанию" + Ин + ".ЗначениеРеквизита = &ЗначениеРеквизита" + Ин + "
		|		ИЛИ втНастройкиПоУмолчанию" + Ин + ".ЗначениеРеквизита = ЗНАЧЕНИЕ(Справочник.ЭД_ЗначенияАналитик.ПустаяСсылка))
		|";
		
		Запрос.УстановитьПараметр("Реквизит" 			+ Ин,	ТекСтрока.Реквизит);
		стрЗначение = РеквизитыДокумента.Найти(ТекСтрока.Реквизит, "Реквизит");
		Запрос.УстановитьПараметр("ЗначениеРеквизита" 	+ Ин, ?(стрЗначение = Неопределено, Справочники.ЭД_ЗначенияАналитик.ПустаяСсылка(), стрЗначение.ЗначениеРеквизита));
		
	КонецЦикла;
	
	ТекстЗапроса = ТекстЗапроса +  "
	|;
	|	
	|////////////////////////////////////////////////////////////////////////////////
	|ВЫБРАТЬ
	|	втНастройки.НастройкаОтображения КАК НастройкаОтображения,
	|	втНастройки.НастройкаПравилаПроверки КАК НастройкаПравилаПроверки,
	|	втНастройки.НастройкаМакетаИмпорта КАК НастройкаМакетаИмпорта,
	|	втНастройки.НастройкаРасчета КАК НастройкаРасчета
	|ИЗ
	|	втНастройки КАК втНастройки
	|ГДЕ
	|	ИСТИНА
	|";            	
	
	
	Для Ин = 1 По тзНастройкиМодели.Количество() Цикл
		ТекстЗапроса = ТекстЗапроса +  "
		|И втНастройки.ЗначениеРеквизита" + Ин + " В (&ЗначениеРеквизита" + Ин + ",	ЗНАЧЕНИЕ(Справочник.ЭД_ЗначенияАналитик.ПустаяСсылка))";		
	КонецЦикла;	
	
	Если тзНастройкиМодели.Количество() > 0 Тогда
		ТекстЗапроса = ТекстЗапроса +  "
		|УПОРЯДОЧИТЬ ПО
		|Приоритет1		
		|";
	КонецЕсли;	
		
	Для Ин = 2 По тзНастройкиМодели.Количество() Цикл
		ТекстЗапроса = ТекстЗапроса +  ",
		|Приоритет" + Ин;		
	КонецЦикла;	
	
	
	Запрос.Текст = ТекстЗапроса;
	РезультатЗапроса = Запрос.Выполнить();
	
	Выборка = РезультатЗапроса.Выбрать();
	
	СтруктураНастроек = Новый Структура;
	СтруктураНастроек.Вставить("НастройкаОтображения",	Модель.НастройкаОтображенияПоУмолчанию);
	СтруктураНастроек.Вставить("НастройкаРасчета",		Модель.НастройкаРасчетаПоУмолчанию);
	СтруктураНастроек.Вставить("НастройкаПравилаПроверки",		Модель.НастройкаПравилаПроверкиПоУмолчанию);
	СтруктураНастроек.Вставить("НастройкаМакетаИмпорта",		Модель.НастройкаМакетаИмпортаПоУмолчанию);

	Если Выборка.Следующий() Тогда
		СтруктураНастроек.Вставить("НастройкаОтображения",	Выборка.НастройкаОтображения);
		СтруктураНастроек.Вставить("НастройкаРасчета",		Выборка.НастройкаРасчета);
		СтруктураНастроек.Вставить("НастройкаПравилаПроверки",		Выборка.НастройкаПравилаПроверки);
		СтруктураНастроек.Вставить("НастройкаМакетаИмпорта",		Выборка.НастройкаМакетаИмпорта);
	КонецЕсли;
	
	Возврат СтруктураНастроек;
	
КонецФункции	

Функция ПолучитьЗначенияДокумента(Документ) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
		"ВЫБРАТЬ
		|	ЗначенияРС.Показатель КАК Показатель,
		|	ЗначенияРС.НомерСтрокиДанных КАК НомерСтрокиДанных,
		|	ЗначенияРС.ЭлектронныйДокумент КАК ЭлектронныйДокумент,
		|	СУММА(ЗначенияРС.ЗначениеПоказателя) КАК ЗначениеПоказателя
		|ИЗ
		|	РегистрСведений.ЗначенияРС КАК ЗначенияРС
		|ГДЕ
		|	ЗначенияРС.ЭлектронныйДокумент = &Документ
		|
		|СГРУППИРОВАТЬ ПО
		|	ЗначенияРС.Показатель,
		|	ЗначенияРС.НомерСтрокиДанных,
		|	ЗначенияРС.ЭлектронныйДокумент";
	
	Запрос.УстановитьПараметр("Документ", Документ);
	
	Возврат Запрос.Выполнить().Выгрузить();
	
КонецФункции	

Функция ПолучитьЗначенияАналитикДокумента(Документ) Экспорт
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
		"ВЫБРАТЬ
		|	АналитикаРС.Показатель КАК Показатель,
		|	АналитикаРС.НомерСтрокиДанных КАК НомерСтрокиДанных,
		|	АналитикаРС.ЭлектронныйДокумент КАК ЭлектронныйДокумент,
		|	АналитикаРС.Аналитика КАК Аналитика,
		|	АналитикаРС.ЗначениеАналитики КАК ЗначениеАналитики,
		|	АналитикаРС.АналитикаПоказателя КАК АналитикаПоказателя
		|ИЗ
		|	РегистрСведений.АналитикаРС КАК АналитикаРС
		|ГДЕ
		|	АналитикаРС.ЭлектронныйДокумент = &Документ
		|
		|СГРУППИРОВАТЬ ПО
		|	АналитикаРС.Показатель,
		|	АналитикаРС.НомерСтрокиДанных,
		|	АналитикаРС.ЭлектронныйДокумент,
		|	АналитикаРС.АналитикаПоказателя,
		|	АналитикаРС.ЗначениеАналитики,
		|	АналитикаРС.Аналитика
		|
		|ИМЕЮЩИЕ
		|	СУММА(АналитикаРС.ИспользованиеАналитики) <> 0";
	
	Запрос.УстановитьПараметр("Документ", Документ);
	
	Возврат Запрос.Выполнить().Выгрузить();
	
КонецФункции	

Функция ПолучитьПериодЭД(ЭлектронныйДокумент, АналитикаПериод = Неопределено) Экспорт
	
	ПустойПериод 	= Справочники.ЭД_ЗначенияАналитик.ПустаяСсылка();
	
	Если ЗначениеЗаполнено(ЭлектронныйДокумент) Тогда
		НайденнаяСтрока = ЭлектронныйДокумент.РеквизитыДокумента.Найти(АналитикаПериод, "Реквизит");
		Если НайденнаяСтрока <> Неопределено Тогда
			Возврат НайденнаяСтрока.ЗначениеРеквизита;
		КонецЕсли;	
	КонецЕсли;		
	
	Возврат ПустойПериод;
	
КонецФункции	

Функция ПолучитьПериодСоСдвигом(Период, Знач ПериодичностьСдвига, Сдвиг = 0) Экспорт
	
	Если ТипЗнч(ПериодичностьСдвига) = Тип("Строка") Тогда
		ПериодичностьСдвига = Перечисления.ЭД_Периодичность.Год;   // по умолчанию
		Если НРег(ПериодичностьСдвига) = "год" Тогда
			ПериодичностьСдвига = Перечисления.ЭД_Периодичность.Год;
		ИначеЕсли НРег(ПериодичностьСдвига) = "двагода" Тогда
			ПериодичностьСдвига = Перечисления.ЭД_Периодичность.ДваГода;
		ИначеЕсли НРег(ПериодичностьСдвига) = "тригода" Тогда
			ПериодичностьСдвига = Перечисления.ЭД_Периодичность.ТриГода;
		ИначеЕсли НРег(ПериодичностьСдвига) = "пятьлет" Тогда
			ПериодичностьСдвига = Перечисления.ЭД_Периодичность.ПятьЛет;
		ИначеЕсли НРег(ПериодичностьСдвига) = "день" Тогда
			ПериодичностьСдвига = Перечисления.ЭД_Периодичность.День;
		ИначеЕсли НРег(ПериодичностьСдвига) = "неделя" Тогда
			ПериодичностьСдвига = Перечисления.ЭД_Периодичность.Неделя;
		ИначеЕсли НРег(ПериодичностьСдвига) = "месяц" Тогда
			ПериодичностьСдвига = Перечисления.ЭД_Периодичность.Месяц;
		ИначеЕсли НРег(ПериодичностьСдвига) = "квартал" Тогда
			ПериодичностьСдвига = Перечисления.ЭД_Периодичность.Квартал;
		ИначеЕсли НРег(ПериодичностьСдвига) = "полугодие" Тогда
			ПериодичностьСдвига = Перечисления.ЭД_Периодичность.Полугодие;
		КонецЕсли;	
	КонецЕсли;	
	
	ТипПериоды 		= ПланыВидовХарактеристик.ЭД_ТипыАналитик.Периоды;
	ПустойПериод 	= Справочники.ЭД_ЗначенияАналитик.ПустаяСсылка();
	
	Запрос = Новый Запрос;
	Запрос.Текст = 
		"ВЫБРАТЬ
		|	ЭД_ЗначенияАналитик.Ссылка КАК Ссылка
		|ИЗ
		|	Справочник.ЭД_ЗначенияАналитик КАК ЭД_ЗначенияАналитик
		|ГДЕ
		|	ЭД_ЗначенияАналитик.Владелец = &ТипПериоды
		|	И ЭД_ЗначенияАналитик.ДатаНачала = &ДатаНачала
		|	И ЭД_ЗначенияАналитик.Периодичность = &Периодичность";
	
	День = 60*60*24;
	
	ДатаНачала = Период.ДатаНачала;
	Если ПериодичностьСдвига = Перечисления.ЭД_Периодичность.Год Тогда
		ДатаНачала = ДобавитьМесяц(ДатаНачала, 12 * Сдвиг);
	ИначеЕсли ПериодичностьСдвига = Перечисления.ЭД_Периодичность.ДваГода Тогда
		ДатаНачала = ДобавитьМесяц(ДатаНачала, 24 * Сдвиг);
	ИначеЕсли ПериодичностьСдвига = Перечисления.ЭД_Периодичность.ТриГода Тогда
		ДатаНачала = ДобавитьМесяц(ДатаНачала, 36 * Сдвиг);
	ИначеЕсли ПериодичностьСдвига = Перечисления.ЭД_Периодичность.ПятьЛет Тогда
		ДатаНачала = ДобавитьМесяц(ДатаНачала, 60 * Сдвиг);
	ИначеЕсли ПериодичностьСдвига = Перечисления.ЭД_Периодичность.День Тогда
		ДатаНачала = ДатаНачала + День * Сдвиг;
	ИначеЕсли ПериодичностьСдвига = Перечисления.ЭД_Периодичность.Неделя Тогда
		ДатаНачала = ДатаНачала + День * 7 * Сдвиг;
	ИначеЕсли ПериодичностьСдвига = Перечисления.ЭД_Периодичность.Месяц Тогда
		ДатаНачала = ДобавитьМесяц(ДатаНачала, 1 * Сдвиг);
	ИначеЕсли ПериодичностьСдвига = Перечисления.ЭД_Периодичность.Квартал Тогда
		ДатаНачала = ДобавитьМесяц(ДатаНачала, 3 * Сдвиг);
	ИначеЕсли ПериодичностьСдвига = Перечисления.ЭД_Периодичность.Полугодие Тогда
		ДатаНачала = ДобавитьМесяц(ДатаНачала, 6 * Сдвиг);
	КонецЕсли;	
	
	Запрос.УстановитьПараметр("ДатаНачала", 	ДатаНачала);
	Запрос.УстановитьПараметр("Периодичность", 	Период.Периодичность);
	Запрос.УстановитьПараметр("ТипПериоды", 	ТипПериоды);
	
	РезультатЗапроса = Запрос.Выполнить();
	
	ВыборкаДетальныеЗаписи = РезультатЗапроса.Выбрать();
	
	Если ВыборкаДетальныеЗаписи.Следующий() Тогда
		Возврат ВыборкаДетальныеЗаписи.Ссылка;	
	КонецЕсли;
	
	Возврат ПустойПериод;
	
КонецФункции	       

Функция ПолучитьПериодСоСдвигомЭД(ЭлектронныйДокумент, АналитикаПериод, ПериодичностьСдвига, Сдвиг = 0) Экспорт
	
	ПериодДокумента 	= Справочники.ЭД_ЗначенияАналитик.ПустаяСсылка();
	
	Если ЗначениеЗаполнено(ЭлектронныйДокумент) Тогда
		НайденнаяСтрока = ЭлектронныйДокумент.РеквизитыДокумента.Найти(АналитикаПериод, "Реквизит");
		Если НайденнаяСтрока <> Неопределено Тогда
			ПериодДокумента = НайденнаяСтрока.ЗначениеРеквизита;
		КонецЕсли;	
	КонецЕсли;	
	
	Если Не ЗначениеЗаполнено(ПериодДокумента) Тогда
		Возврат ПериодДокумента;
	КонецЕсли;
	
	Возврат ПолучитьПериодСоСдвигом(ПериодДокумента, ПериодичностьСдвига, Сдвиг);
	
КонецФункции	

Функция СформироватьНаименованиеПериода(Периодичность, ДатаНачала, ДатаОкончания = Неопределено) Экспорт
	
	Если Периодичность = Перечисления.ЭД_Периодичность.Год Тогда
		Наименование 	= Формат(ДатаНачала, "ДФ='гггг ''г.'''");
	ИначеЕсли Периодичность = Перечисления.ЭД_Периодичность.Полугодие Тогда
		Если Месяц(ДатаНачала) = 1 Тогда
			Наименование 	= Формат(ДатаНачала, "ДФ='''1 полугодие'' гггг ''г.'''");
		Иначе	
			Наименование 	= Формат(ДатаНачала, "ДФ='''2 полугодие'' гггг ''г.'''");
		КонецЕсли;	
	ИначеЕсли Периодичность = Перечисления.ЭД_Периодичность.Квартал Тогда
		Наименование 	= Формат(ДатаНачала, "ДФ='к ''квартал'' гггг ''г.'''");
	ИначеЕсли Периодичность = Перечисления.ЭД_Периодичность.Месяц Тогда
		Наименование 	= Формат(ДатаНачала, "ДФ='ММММ гггг'' г.'''");
	ИначеЕсли Периодичность = Перечисления.ЭД_Периодичность.Неделя Тогда
		Наименование 	= Формат(ДатаНачала, "ДФ='''" + НеделяГода(ДатаНачала) + " неделя'' гггг'' г.'''");
	ИначеЕсли Периодичность = Перечисления.ЭД_Периодичность.ДваГода Или Периодичность = Перечисления.ЭД_Периодичность.ТриГода Или Периодичность = Перечисления.ЭД_Периодичность.ПятьЛет Тогда
		Наименование 	= Формат(ДатаНачала, "ДФ=гггг") + "-" + Формат(ДатаОкончания, "ДФ='гггг ''гг.'''");
	Иначе
		Наименование = Формат(ДатаНачала, "ДФ=dd.MM.yyyy");
	КонецЕсли;	
	
	Возврат Наименование;      	
	
КонецФункции	

//Функция ПолучитьИмяПриложенияСеанса(НомерСоединения, Представление = Ложь)
//НомерСоединения (Число) номер соединения по которому необходимо получить контекст сеанса
//Представление (Булево) - если Истина то функция вернет представления контекста сеанса (удобочитаемое) 
//Пример ИмяПриложения: "WebServerExtension" Представление:"Модуль расширения веб-сервера"
//Возвращает (Строка) - имя приложения (Контекст сеанса) или представление имени приложения
//
Функция ПолучитьИмяПриложенияСеанса(НомерСоединения, Представление = Ложь) Экспорт
    ИмяПриложения = "";  
	  
    СеансыИБ         = ПолучитьСеансыИнформационнойБазы();        
    Для Каждого Сеанс Из СеансыИБ Цикл         
        Если Сеанс.НомерСоединения = НомерСоединения Тогда
            Если Представление Тогда
				ИмяПриложения = ПредставлениеПриложения(Сеанс.ИмяПриложения); 
			Иначе
				ИмяПриложения = Сеанс.ИмяПриложения;
			КонецЕсли; 
        КонецЕсли;   
    КонецЦикла;
	
    Возврат ИмяПриложения;
    
КонецФункции