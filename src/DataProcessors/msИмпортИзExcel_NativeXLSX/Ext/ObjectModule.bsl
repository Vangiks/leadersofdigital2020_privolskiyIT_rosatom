Перем ТаблицаЛистов,ТаблицаИменованныхОбластей,мТекущийZipКаталог,КэшПеременныхЗаполнен,МассивSharedStrings,СоответствиеNumFmtIdFormatCode,МассивNumFmtId;
///___мкском___ЗБА___2016/07/01___Начало___№№10808№№___

////////////////////////////////////////////////////////////////////////////////
// ПЕРЕМЕННЫЕ МОДУЛЯ

////////////////////////////////////////////////////////////////////////////////
// ЭКСПОРТНЫЕ ПРОЦЕДУРЫ И ФУНКЦИИ

// Метод "NativeXLSX" (1C ЧтениеXML).
// Считывает данные указанного листа Excel в табличный документ.
//
// Параметры:
//      ФайлEXCEL  - Строка - Полное имя файла (путь к файлу с именем файла и расширением),
//      ИмяЛиста  -  Строка - Имя выбранного листа файла EXCEL
//      СоответствиеИмпортируемыхОбластей  - Соответствие - соответствие именованных областей массиву массивов значений колонок (необходимо для корректного импорта данных в НО)
//
// Возвращаемые значения:
//        ТаблицаРезультат  - ТабличныйДокумент - Результат считывания с листа "ИмяНомерЛиста" EXCEL.
//
Функция ЗагрузитьМетодом_NativeXLSX(Знач ФайлEXCEL, Знач ИмяЛиста, СоответствиеИмпортируемыхОбластей = Неопределено,УдалятьФайл = Истина, БитыеЯчейки = "") Экспорт       // КАВ 16.05.2017 добавил  битые ссылки
	
	//Перем ФайлИмяЛиста, ФайлНомерЛиста, КолвоКолонокExcel, НомерСтроки, ЗначениеЯчейки, ИмяКолонки, ИмяКолонкиБезЦифр, ИндексКолонки,  ШиринаКолонки, ДлинаСтроки, КоличествоСлужебныхКолонок;
	//Перем МассивИменКолонокXLSX, МассивSharedStrings, МассивNumFmtId, СоответствиеNumFmtIdFormatCode;
	//Перем ЭтоНачалоДанных, ТипЗначения, ФорматЯчейки, ИндексФормата, ФорматСтиля;
	//Перем ТаблицаРезультат, НоваяСтрока, ОпределитьКоличествоСтрок;
	
	ТаблицаРезультат = Новый ТабличныйДокумент;
	ОписаниеПримитивныхТипов = Новый ОписаниеТипов("Дата, Число, Булево, Строка");
	
    //в функцию может уже передаваться распакованный каталог, для увеличения быстродействия при пакетной загрузке из нескольких листов
	Если Не ЗначениеЗаполнено(мТекущийZipКаталог) ИЛИ УдалятьФайл = Истина Тогда		
		ФайлРаспакован = СформироватьZIPКаталог(ФайлEXCEL);
		Если ФайлРаспакован <> Истина Тогда	
			Возврат ТаблицаРезультат;	
		КонецЕсли;
	КонецЕсли;
	
	ZIPКаталог = мТекущийZipКаталог;
	
	
	// определение индекса листа по имени
	
	Если ТаблицаЛистов = Неопределено Тогда	
		ЗаполнитьТаблицуЛистов(ZIPКаталог);	
	КонецЕсли;	
	
	// выбор листа из списка в клиенте
	#Если Клиент Тогда
		
		Если НЕ ЗначениеЗаполнено(ИмяЛиста) Тогда
			
			СписокЛистов = Новый СписокЗначений;
			СписокЛистов.ЗагрузитьЗначения(ТаблицаЛистов.ВыгрузитьКолонку("name"));
			СписокЛистов.СортироватьПоЗначению();
			
			Если СписокЛистов.Количество() = 1 Тогда
				ИмяЛиста = СписокЛистов[0].Значение;
			Иначе
				ВыбЭлем = СписокЛистов.ВыбратьЭлемент("Выберите лист");
				Если ВыбЭлем = Неопределено Тогда
					УдалитьФайлы(ZIPКаталог); //___m.s.__20140404___DNovoselov___
					Возврат ТаблицаРезультат;
				Иначе
					ИмяЛиста = ВыбЭлем.Значение;
				КонецЕсли;
			КонецЕсли;
			
		КонецЕсли;
		
	#КонецЕсли
	
	//___m.s.__20140704___AKurlov___Begin___
	Если ТипЗнч(ИмяЛиста)=Тип("Число") Тогда
		//СтрЛиста = ТаблицаЛистов.Найти(Строка(ИмяЛиста), "sheetId");
		СтрЛиста = ТаблицаЛистов.Найти(Строка(ИмяЛиста), "rId");
		ИмяЛиста = СтрЛиста.name;
	Иначе	
		СтрЛиста = ТаблицаЛистов.Найти(ИмяЛиста, "name");
	КонецЕсли; 
	//___m.s.__20140704___AKurlov___End___
	Если СтрЛиста = Неопределено Тогда
		Сообщить("Невозможно загрузить данные с листа, т.к. не найден заданный лист:
		|" + ИмяЛиста);
		//___m.s.__20140704___AKurlov___Begin___
		//добавил попытку
		Если УдалятьФайл=Истина Тогда
			Попытка
				УдалитьZIPКаталог(); //___m.s.__20140404___DNovoselov___
			Исключение
				
			КонецПопытки;
		КонецЕсли;
		//___m.s.__20140704___AKurlov___End___
		Возврат ТаблицаРезультат;
	КонецЕсли;
	
	ИндексСтрокиЛиста = СтрЛиста.rid;
	ИндексЛиста = СтрЛиста.sheetId;
	
	// сразу определим области выбранного листа
	
	МсвИменованныхОбластей = Новый Массив; // массив именованных локальных областей листа
	Для Каждого СтрИменованнаяОбласть Из ТаблицаИменованныхОбластей Цикл
		
		Если Найти(ВРег(СтрИменованнаяОбласть.address), ВРег("'" + ИмяЛиста + "'!")) > 0
				ИЛИ Найти(ВРег(СтрИменованнаяОбласть.address), ВРег(ИмяЛиста) + "!") > 0 Тогда
			МсвИменованныхОбластей.Добавить(СтрИменованнаяОбласть);
		КонецЕсли;
		
	КонецЦикла;
	
	Если КэшПеременныхЗаполнен = Ложь Тогда
		// определение массива общих строк книги
		
		МассивSharedStrings = ПолучитьМассивSharedStrings(ZIPКаталог + "XL\");   	
		
		// определение форматов строк
		
		СоответствиеNumFmtIdFormatCode = Новый Соответствие;      // перенесено в  СформироватьZIPКаталог
		МассивNumFmtId = ПолучитьМассивМассивNumFmtId(ZIPКаталог + "XL\", СоответствиеNumFmtIdFormatCode); 
		КэшПеременныхЗаполнен = Истина;
	КонецЕСли;
	
	//// определение имен колонок
	//
	//МассивИменКолонокXLSX = Новый Массив;
	//ПолучитьМассивИменКолонокXLSX(КолвоКолонокExcel, МассивИменКолонокXLSX, -1);
	
	
	
	// чтение данных листа
	
	SheetX = Новый ЧтениеXML;
	SheetX.ОткрытьФайл(ZIPКаталог + "XL\WorkSheets\Sheet" + ИндексСтрокиЛиста + ".xml");
	
	Пока SheetX.Прочитать() Цикл // цикл по строкам
		
		Если ВРег(SheetX.Имя) = "SHEETDATA" И SheetX.ТипУзла = ТипУзлаXML.КонецЭлемента Тогда
			Прервать;   // окончание данных листа
		КонецЕсли;
		
		Если ВРег(SheetX.Имя) = "ROW" И SheetX.ТипУзла = ТипУзлаXML.НачалоЭлемента Тогда
			
			НомерСтроки = SheetX.ЗначениеАтрибута("r");
			
			Пока SheetX.Прочитать() Цикл // цикл по колонкам
				
				Если ВРег(SheetX.Имя) = "ROW" И SheetX.ТипУзла = ТипУзлаXML.КонецЭлемента Тогда
					Прервать;   // окончание строки
				КонецЕсли;
				
				Если ВРег(SheetX.Имя) = "C" И SheetX.ТипУзла = ТипУзлаXML.НачалоЭлемента Тогда
					
					ИмяКолонки = SheetX.ЗначениеАтрибута("r");
					Координаты = ВернутьКоординатыКолонки(ИмяКолонки);
					
					ТипЗначения = SheetX.ЗначениеАтрибута("t");
					ФорматЯчейки = SheetX.ЗначениеАтрибута("s");
					
					Пока SheetX.Прочитать() Цикл // цикл по свойствам ячейки (ищем значение)
						
						Если ВРег(SheetX.Имя) = "C" И SheetX.ТипУзла = ТипУзлаXML.КонецЭлемента Тогда
							Прервать;   // окончание ячейки
						КонецЕсли;
						
						Если ВРег(SheetX.Имя) = "V" Тогда
							
							SheetX.Прочитать();
							Если ВРег(SheetX.Имя) = "#TEXT" Тогда
								
								ЗначениеЯчейки = SheetX.Значение;
								
								ФорматСтиля = "";
								Если (НЕ ФорматЯчейки = "" И НЕ ФорматЯчейки = Неопределено) Тогда
									Попытка
										ИндексФормата = Число(ФорматЯчейки);
										ФорматСтиля = СоответствиеNumFmtIdFormatCode.Получить(МассивNumFmtId[ИндексФормата]);
									Исключение
										ФорматСтиля = "";
									КонецПопытки;
								КонецЕсли;
								
								Если ЗначениеЗаполнено(ЗначениеЯчейки) Тогда
									Если ТипЗначения = Неопределено ИЛИ ВРег(ТипЗначения) = "N" Тогда
										//___m.s.140708___AKurlov___Begin___ 
										//Попытка
										//	Значение1 = Число(ЗначениеЯчейки);
										//Исключение
										//	Значение1 = ЗначениеЯчейки;
										//КонецПопытки;
										//ЗначениеЯчейки = Значение1;
										//___m.s.140708___AKurlov___End___ 
										Если (ФорматСтиля = "" ИЛИ ФорматСтиля = Неопределено) Тогда
											// ФорматСтиля = Неопределено - Атрибут "s" отсутствует.
											// MS Office (2010) может не формировать в xml-файле описание стиля форматирования для ячейки.
											// LibreOffice (4.1.5) формирует в xml-файле необходимые описания стиля форматирования ячейки.
										КонецЕсли;
										//__мкском__ЖАВ__160804 начало   Дата
										Если ФорматСтиля = "DD.MM.YYYY" Тогда
											ЗначениеЯчейки = КонвертироватьЧислоXLSXвДату(ЗначениеЯчейки); //если дата формата DD.MM.YYYY (без времени)
											///___мкском___ЖАВ___2016/11/12___Начало___№№.№№___
											///было
											
											///стало ЗначениеЯчейки = СокрЛП(ЗначениеЯчейки);
													ОбластьЗначения = ТаблицаРезультат.Область(Координаты.Строка, Координаты.Колонка);
													
													ОбластьЗначения.СодержитЗначение = Истина;
													//ОбластьЗначения.ТипЗначения = Тип("Дата");
													ОбластьЗначения.ТипЗначения = ОписаниеПримитивныхТипов;
													ОбластьЗначения.Значение = ЗначениеЯчейки;
													Прервать;
											///___мкском___ЖАВ___2016/11/12___Окончание___ 
											///___мкском___ЗБА___2016/10/28___Начало___№№№№___
											///для числа тип не определяется, только формат стиля(например "# ##0\ ;-# ##0\ ;" -"#\ ;@"), поэтому предполагаем, что может быть число
										ИначеЕсли  ЭтоЧислоXLSX(ЗначениеЯчейки, ФорматСтиля) Тогда								
											Попытка 
												ЗначениеЯчейки = Число(ЗначениеЯчейки);
											Исключение
											КонецПопытки;
											
											///___мкском___ЗБА___2016/10/28___Окончание___
											
										КонецЕсли;	
										//__мкском__ЖАВ__160804 конец

										Если ТипЗнч(ЗначениеЯчейки) = Тип("Число") Тогда
											// ПРОЦЕНТ.
											Если ЭтоПроцентXLSX(ЗначениеЯчейки, ФорматСтиля) Тогда
												///___мкском___ЖАВ___2016/11/18___Начало___№№.№№___  подгоняем под консолидацию
												//было
												//ЗначениеЯчейки = ЗначениеЯчейки * 100;
												//стало
												///___мкском___ЖАВ___2016/11/18___Окончание___ 
												// ВРЕМЯ.
											ИначеЕсли (ЗначениеЯчейки < 1 И ЭтоВремяXLSX(ЗначениеЯчейки, ФорматСтиля)) Тогда
												ЗначениеЯчейки = КонвертироватьЧислоXLSXвДатуВремя(ЗначениеЯчейки);
												// ДАТА.
											ИначеЕсли (ЗначениеЯчейки = Цел(ЗначениеЯчейки) И ЭтоДатаXLSX(ЗначениеЯчейки, ФорматСтиля)) Тогда
												ЗначениеЯчейки = КонвертироватьЧислоXLSXвДату(ЗначениеЯчейки);
												// ЧИСЛО.
											ИначеЕсли ТипЗначения = Неопределено
												ИЛИ ( ЭтоЧислоXLSX(ЗначениеЯчейки, ФорматСтиля)
												И НЕ ЭтоВремяXLSX(ЗначениеЯчейки, ФорматСтиля)
												И НЕ ЭтоДатаXLSX(ЗначениеЯчейки, ФорматСтиля) )
												Тогда
												// Без дальнейших преобразований.
											Иначе
												// Прочие форматы.
											КонецЕсли;
										Иначе
											//___m.s.__20140321___DNovoselov___Begin___
											// разбор чисел в формате XXXXXXXE-YYY и XXXXXXXE+YYY
											Поз = Найти(ЗначениеЯчейки, "E-");
											Если Поз = 0 Тогда
												Поз = Найти(ЗначениеЯчейки, "E+");
											КонецЕсли;
											Если Поз > 0 Тогда
												Попытка
													ЗначениеЯчейки = Число(Лев(ЗначениеЯчейки,Поз-1)) * Pow(10, Число(Сред(ЗначениеЯчейки,Поз+1)));
												Исключение
												КонецПопытки;
											//// ЧИСЛО.
											//Если Прав(ЗначениеЯчейки, 5) = "E-003" Тогда
											//	УдалитьПоследнийСимволВСтроке(ЗначениеЯчейки, 5);
											//	Попытка
											//		ЗначениеЯчейки = Число(ЗначениеЯчейки);
											//	Исключение
											//	КонецПопытки;
											//	// ЧИСЛО.
											//ИначеЕсли Прав(ЗначениеЯчейки, 3) = "E-3" Тогда
											//	УдалитьПоследнийСимволВСтроке(ЗначениеЯчейки, 3);
											//	Попытка
											//		ЗначениеЯчейки = Число(ЗначениеЯчейки);
											//	Исключение
											//	КонецПопытки;
											//___m.s.__20140321___DNovoselov___End___
												// ВРЕМЯ.
											ИначеЕсли ЭтоВремяXLSX(ЗначениеЯчейки, ФорматСтиля) Тогда
												ЗначениеЯчейки = КонвертироватьЧислоXLSXвДатуВремя(ЗначениеЯчейки);
											/////___мкском___ЖАВ___2016/11/25___Начало___№№.№№___
											/////было
											//
											/////стало 
											//ИначеЕсли ТипЗначения = Неопределено И ТипЗнч(ЗначениеЯчейки) = Тип("Строка") Тогда
											//		ЗначениеЯчейки = СокрЛП(ЗначениеЯчейки);
											//		ОбластьЗначения = ТаблицаРезультат.Область(Координаты.Строка, Координаты.Колонка);
											//		
											//		ОбластьЗначения.СодержитЗначение = Ложь;
											//		//ОбластьЗначения.ТипЗначения = Тип("Строка");
											//		ОбластьЗначения.Текст = ЗначениеЯчейки;
											//		Прервать;

											/////___мкском___ЖАВ___2016/11/25___Окончание___ 
											Иначе
												///___мкском___ЖАВ___2016/11/11___Начало___№№.№№___
												///было
												
												///стало 
												Попытка 
													ЗначениеЯчейки = Число(СокрЛП(СтрЗаменить(ЗначениеЯчейки," ","")));
												Исключение
													ЗначениеЯчейки = СокрЛП(ЗначениеЯчейки);
													ОбластьЗначения = ТаблицаРезультат.Область(Координаты.Строка, Координаты.Колонка);
													
													ОбластьЗначения.СодержитЗначение = Ложь;
													//ОбластьЗначения.ТипЗначения = Тип("Строка");
													ОбластьЗначения.Текст = ЗначениеЯчейки;
													Прервать;
	
												КонецПопытки; 
												///___мкском___ЖАВ___2016/11/11___Окончание___ 
												// Прочие форматы.  												
												
											КонецЕсли;
										КонецЕсли;
										
										
									ИначеЕсли ВРег(ТипЗначения) = "S" Тогда
										// МассивSharedStrings может быть пустым.
										/////___мкском___ЖАВ___2016/11/25___Начало___№№.№№___
										/////было
										//
										/////стало   Дата   неправильно преобразуется из неправильной даты
										//Если ФорматСтиля = "DD.MM.YYYY" Тогда
										//	ЗначениеЯчейки = КонвертироватьЧислоXLSXвДату(ЗначениеЯчейки); //если дата формата DD.MM.YYYY (без времени)
										//			ОбластьЗначения = ТаблицаРезультат.Область(Координаты.Строка, Координаты.Колонка);
										//			ОбластьЗначения.СодержитЗначение = Истина;
										//			ОбластьЗначения.ТипЗначения = ОписаниеПримитивныхТипов;
										//			ОбластьЗначения.Значение = ЗначениеЯчейки;
										//			Прервать;
										//КонецЕсли;
										//	///___мкском___ЖАВ___2016/11/25___Окончание__
										
										
										//МКСКОМ_ЖАВ_20170215_начало (РАСКОММЕНТИРОВАТЬ, если неважно расхождение с конс. (там такие даты тоже не грузились))
										Если ФорматСтиля = "DD.MM.YYYY" Тогда //если дата формата DD.MM.YYYY (без времени)
											Попытка
												ЗначениеЯчейки = ЭД_СтроковыеФункцииКлиентСервер.СтрокаВДату(МассивSharedStrings[Число(SheetX.Значение)]);
												ОбластьЗначения = ТаблицаРезультат.Область(Координаты.Строка, Координаты.Колонка);
												
												//___m.s.170303___VA___Begin___
												Если ЗначениеЯчейки = Дата(1,1,1) И ЗначениеЗаполнено(МассивSharedStrings[Число(SheetX.Значение)]) Тогда 
													ОбластьЗначения.СодержитЗначение = Ложь;
													ОбластьЗначения.Текст = МассивSharedStrings[Число(SheetX.Значение)];
													Прервать;
												КонецЕсли;
												//___m.s.170303_
												
												
												ОбластьЗначения.СодержитЗначение = Истина;
												ОбластьЗначения.ТипЗначения = ОписаниеПримитивныхТипов;
												ОбластьЗначения.Значение = ЗначениеЯчейки;
												Прервать;
											Исключение
												ЗначениеЯчейки = "";
												ОбластьЗначения = ТаблицаРезультат.Область(Координаты.Строка, Координаты.Колонка);
												ОбластьЗначения.СодержитЗначение = Ложь;
												ОбластьЗначения.Текст = ЗначениеЯчейки;
												Прервать;
											КонецПопытки;
													
										КонецЕсли;
										//МКСКОМ_ЖАВ_20170215_конец
										Попытка
											ЗначениеЯчейки = МассивSharedStrings[Число(SheetX.Значение)];
										Исключение
											ЗначениеЯчейки = "";
										КонецПопытки;
										ОбластьЗначения = ТаблицаРезультат.Область(Координаты.Строка, Координаты.Колонка);
										
										ОбластьЗначения.СодержитЗначение = Ложь;
										//ОбластьЗначения.ТипЗначения = Тип("Строка");
										ОбластьЗначения.Текст = ЗначениеЯчейки;
										Прервать;
										//ЗначениеЯчейки = СокрЛП(ЗначениеЯчейки);
					
									ИначеЕсли ВРег(ТипЗначения) = "STR" Тогда
									// Формула. Оставляем "как есть".
									///___мкском___ЖАВ___2016/08/02 начало
									ИначеЕсли ВРег(ТипЗначения) = "B" Тогда
										// Булево. 
										Если ЗначениеЯчейки="1" Тогда 
											  ЗначениеЯчейки = Истина;
										ИначеЕсли  ЗначениеЯчейки="0" Тогда 
											  ЗначениеЯчейки = Ложь;
										КонецЕсли;
									///___мкском___ЖАВ___2016/08/02 конец
									
									/////___мкском___БМВ___2017/03/01 начало
									ИначеЕсли ВРег(ТипЗначения) = "E" Тогда          // КАВ 16.05.2017
									    //Малугин {06.04.2018
										//БитыеЯчейки = БитыеЯчейки + "В строке №"+Координаты.Строка+" колонка №"+Координаты.Колонка+" битая ссылка."+Символы.ПС;
										//БланкБитыеСсылки = Справочники.ПроизвольныеБланкиФорм.НайтиПоНаименованию("БитыеСсылкиИсключения", , , Справочники.ВидыОтчетов.НайтиПоКоду("Баланс_ЕПС_2011"));								
										//Выполнить(БланкБитыеСсылки.АлгоритмФормирования);
										//Малугин }
									//	ОбластьЗначения = ТаблицаРезультат.Область(Координаты.Строка, Координаты.Колонка);
									//	ОбластьЗначения.СодержитЗначение = Ложь;
									//	ОбластьЗначения.Текст = "";
									//	Прервать;
									/////___мкском___БМВ___2017/03/01 конец

									КонецЕсли;
								КонецЕсли;
								
								ОбластьЗначения = ТаблицаРезультат.Область(Координаты.Строка, Координаты.Колонка);
								
								ОбластьЗначения.СодержитЗначение = Истина;
								ОбластьЗначения.ТипЗначения = ОписаниеПримитивныхТипов;
								ОбластьЗначения.Значение = ЗначениеЯчейки;
								
							КонецЕсли;
							
							Прервать;   // нашли и записали значение
						КонецЕсли;
						
					КонецЦикла;
					
				КонецЕсли;
				
			КонецЦикла;
			
		КонецЕсли;
		
	КонецЦикла;
	
	// Завершение работы.
	// Закрытие Объектов.
	SheetX.Закрыть();
	
	///___мкском___ЖАВ___2016/11/09___Начало___№№.№№___
	///было
	//// заполнение соответствия импортируемых областей
	
	//Если ТипЗнч(СоответствиеИмпортируемыхОбластей) = Тип("Соответствие") Тогда
	//	
	//	СоответствиеИмпортируемыхОбластей.Очистить();
	//	
	//	Для Каждого СтрИменованнаяОбласть Из МсвИменованныхОбластей Цикл
	//		
	//		Если Найти(СтрИменованнаяОбласть.name, "Аналитика") > 0 Тогда
	//			// пропустим области аналитик
	//			Продолжить;
	//		КонецЕсли;
	//		
	//		// для упрощения предполагаем, что области задаются как диапазон между двух ячеек, например, "A1:AA10" или "$1:$10"
	//		
	//		Попытка
	//			
	//			address = ВРег(СтрИменованнаяОбласть.address);
	//			address = СтрЗаменить(address, ВРег("'" + ИмяЛиста + "'!"), "");
	//			address = СтрЗаменить(address, ВРег(ИмяЛиста + "!"), "");
	//			
	//			Поз = Найти(address, ":");
	//			
	//			Координаты1 = ВернутьКоординатыКолонки(Лев(address, Поз-1));
	//			Координаты2 = ВернутьКоординатыКолонки(Сред(address, Поз+1));
	//			
	//		Исключение
	//			Продолжить;
	//		КонецПопытки;
	//		
	//		Колонка1 = ?(Координаты1.Колонка = -28, 1, Координаты1.Колонка); // -28 = $
	//		Колонка2 = ?(Координаты2.Колонка = -28, ТаблицаРезультат.ШиринаТаблицы, Координаты2.Колонка);
	//		Строка1 = Координаты1.Строка;
	//		Строка2 = Координаты2.Строка;
	//		
	//		МассивТаблица = Новый Массив;
	//		Для Колонка = Колонка1 По Колонка2 Цикл
	//			МассивКолонка = Новый Массив;
	//			Для Строка =Строка1 По Строка2 Цикл
	//				Область = ТаблицаРезультат.Область(Строка, Колонка);
	//				Если Область.СодержитЗначение = Истина Тогда
	//					МассивКолонка.Добавить(Область.Значение);
	//				Иначе
	//					МассивКолонка.Добавить(Null);
	//				КонецЕсли;
	//			КонецЦикла;
	//			МассивТаблица.Добавить(МассивКолонка);
	//		КонецЦикла;
	//		
	//		СоответствиеИмпортируемыхОбластей.Вставить(СтрИменованнаяОбласть.name, МассивТаблица);
	//		ТаблицаРезультат.Область(Строка1, Колонка1, Строка2, Колонка2).Имя = СтрИменованнаяОбласть.name;
	//		
	//	КонецЦикла;
	//	
	//КонецЕсли;
	///стало 
	///___мкском___ЖАВ___2016/11/09___Окончание___ 
	Если УдалятьФайл = Истина Тогда	
		УдалитьZIPКаталог(); //___m.s.__20140404___DNovoselov___
	КонецЕСли;	
	
	Возврат ТаблицаРезультат;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ И ФУНКЦИИ ОБЩЕГО НАЗНАЧЕНИЯ

Функция ПолучитьМассивМассивNumFmtId(Каталог, СоответствиеNumFmtIdFormatCode)
	
	МассивNumFmtId = Новый Массив;
	СоответствиеNumFmtIdFormatCode = Новый Соответствие;
	
	Файл = Новый Файл(Каталог + "Styles.xml");
	Если НЕ Файл.Существует() Тогда
		Возврат МассивNumFmtId;
	КонецЕсли;
	
	Styles = Новый ЧтениеXML;
	Styles.ОткрытьФайл(Каталог + "Styles.xml");
	Пока Styles.Прочитать() Цикл
		Если ВРег(Styles.Имя) = ВРег("numFmt") И Styles.ТипУзла = ТипУзлаXML.НачалоЭлемента Тогда
			СоответствиеNumFmtIdFormatCode.Вставить(Styles.ЗначениеАтрибута("numFmtId"), ВРег(Styles.ЗначениеАтрибута("formatCode")));
		КонецЕсли;
		Если ВРег(Styles.Имя) = ВРег("cellXfs") Тогда
			Пока Styles.Прочитать() Цикл
				Если ВРег(Styles.Имя) = ВРег("xf") И Styles.ТипУзла = ТипУзлаXML.НачалоЭлемента Тогда
					МассивNumFmtId.Добавить(Styles.ЗначениеАтрибута("numFmtId"));
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
	КонецЦикла;
	
	// Завершение работы.
	// Закрытие Объектов.
	Styles.Закрыть();
	
	// Проверка сопоставления кодов массива и соответствия.
	// MS Office (2010) может не формировать в xml-файле описание стиля форматирования для ячейки.
	// LibreOffice (4.1.5) формирует в xml-файле необходимые описания стиля форматирования ячейки.
	Для Каждого ит ИЗ МассивNumFmtId Цикл
		Если СоответствиеNumFmtIdFormatCode.Получить(ит) = Неопределено Тогда
			// Сообщить("В описании отсутствует стиль форматирования для кода " + ит);
			Если ит = "0" Тогда // Стандарт для числа (Целое число).
				СоответствиеNumFmtIdFormatCode.Вставить(ит, "GENERAL");
			ИначеЕсли ит = "9" ИЛИ ит = "10" Тогда  // Форматы для % ("0%", "0.00%").
				СоответствиеNumFmtIdFormatCode.Вставить(ит, "0%");
			ИначеЕсли ит = "14" ИЛИ ит = "16" Тогда // Форматы для даты.
				СоответствиеNumFmtIdFormatCode.Вставить(ит, "DD.MM.YYYY");
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	Возврат МассивNumFmtId;
	
КонецФункции

Функция ПолучитьМассивSharedStrings(Каталог)
	
	// Если в файле EXCEL не содержится значений, имеющих тип "СТРОКА", то файл "SharedStrings.xml" не формируется.
	МассивSharedStrings = Новый Массив;
	
	Файл = Новый Файл(Каталог + "SharedStrings.xml");
	Если НЕ Файл.Существует() Тогда
		Возврат МассивSharedStrings;
	КонецЕсли;
	
	SharedStrings = Новый ЧтениеXML;
	SharedStrings.ОткрытьФайл(Каталог + "SharedStrings.xml");
	
	//___m.s.__20140331___DNovoselov___Begin___
	Пока SharedStrings.Прочитать() Цикл
		Если ВРег(SharedStrings.Имя) = "SI" И SharedStrings.ТипУзла = ТипУзлаXML.НачалоЭлемента Тогда
			// далее ищем первый узел T
			КусокЗначения = ""; //__мкском__ЖАВ__160824 т.к. xml разбивает текст с перносом строки на куски
			Пока SharedStrings.Прочитать() Цикл
				Если ВРег(SharedStrings.Имя) = "T" И SharedStrings.ТипУзла = ТипУзлаXML.НачалоЭлемента Тогда
					// в следующем узле должно быть текстовое значение
					SharedStrings.Прочитать();
					Если ВРег(SharedStrings.Имя) = "#TEXT" Тогда
						КусокЗначения = КусокЗначения + " " + SharedStrings.Значение; //__мкском__ЖАВ__160824 было: МассивSharedStrings.Добавить(SharedStrings.Значение);
					//Иначе
					//	МассивSharedStrings.Добавить("");
					КонецЕсли;
					//Прервать;
				КонецЕсли;
				//__мкском__ЖАВ__160824 начало
				Если ВРег(SharedStrings.Имя) = "SI" И SharedStrings.ТипУзла = ТипУзлаXML.КонецЭлемента Тогда
					МассивSharedStrings.Добавить(СокрЛП(КусокЗначения));
					КусокЗначения = "";
					Прервать;
				КонецЕсли;
				//__мкском__ЖАВ__160824 конец
			КонецЦикла;
		КонецЕсли;
	КонецЦикла;
	//Пока SharedStrings.Прочитать() Цикл
	//	Если ВРег(SharedStrings.Имя) = "T" И SharedStrings.ТипУзла = ТипУзлаXML.НачалоЭлемента Тогда
	//		// в следующем узле должно быть текстовое значение
	//		SharedStrings.Прочитать();
	//		Если ВРег(SharedStrings.Имя) = "#TEXT" Тогда
	//			МассивSharedStrings.Добавить(SharedStrings.Значение);
	//		Иначе
	//			МассивSharedStrings.Добавить("");
	//		КонецЕсли;
	//	КонецЕсли;
	//КонецЦикла;
	//___m.s.__20140331___DNovoselov___End___
	
	// Завершение работы.
	// Закрытие Объектов.
	SharedStrings.Закрыть();
	
	Возврат МассивSharedStrings;
	
КонецФункции

Функция ЭтоЧислоXLSX(Знач ЗначениеЯчейки, Знач ФорматСтиля)
	Если ( ВРег(ФорматСтиля) = "GENERAL"
		ИЛИ ВРег(ФорматСтиля) = "STANDARD"
		ИЛИ Найти(ФорматСтиля, "0") > 0
		ИЛИ Прав(ЗначениеЯчейки, 5) = "E-003"
		ИЛИ Прав(ЗначениеЯчейки, 3) = "E-3" )
		Тогда
		Возврат Истина;
	КонецЕсли;
	Возврат Ложь;
КонецФункции

Функция ЭтоПроцентXLSX(Знач ЗначениеЯчейки, Знач ФорматСтиля)
	Если ( Найти(ФорматСтиля, "%") > 0 )
		Тогда
		Возврат Истина;
	КонецЕсли;
	Возврат Ложь;
КонецФункции

Функция ЭтоДатаXLSX(Знач ЗначениеЯчейки, Знач ФорматСтиля)
	Если ( Найти(ФорматСтиля, "DD") > 0
		ИЛИ Найти(ФорматСтиля, "MM") > 0
		ИЛИ Найти(ФорматСтиля, "YY") > 0
		ИЛИ Найти(ФорматСтиля, "QQ") > 0
		ИЛИ Найти(ФорматСтиля, "WW") > 0 )
		Тогда
		Возврат Истина;
	КонецЕсли;
	Возврат Ложь;
КонецФункции

Функция ЭтоВремяXLSX(Знач ЗначениеЯчейки, Знач ФорматСтиля)
	Если ( Найти(ФорматСтиля, "HH:") > 0
		ИЛИ Найти(ФорматСтиля, "[HH]:") > 0
		ИЛИ Найти(ФорматСтиля, "[H]:") > 0
		ИЛИ Найти(ФорматСтиля, "MM:") > 0
		ИЛИ Найти(ФорматСтиля, ":SS") > 0
		ИЛИ Прав(ЗначениеЯчейки, 5) = "E-005"
		ИЛИ Прав(ЗначениеЯчейки, 3) = "E-5"
		ИЛИ Прав(ЗначениеЯчейки, 3) = "E-4" )
		Тогда
		Возврат Истина;
	КонецЕсли;
	Возврат Ложь;
КонецФункции

Функция КонвертироватьЧислоXLSXвДату(Знач Число)
	Перем Дата1900, Разница, ДатаРезультат;
	Дата1900 = Дата("19000101");
	Разница = Число - 2;    // Excel ошибочно считает 1900-й год високосным.
	Разница = ?(Разница < 0, Разница = 0, Разница);
	ДатаРезультат = Дата1900 + Разница * 24 * 60 * 60;
	Возврат ДатаРезультат;
КонецФункции

Функция КонвертироватьЧислоXLSXвДатуВремя(Знач Число)
	Перем Делитель, КВоСекунд, КВоСекунд1;
	Перем ВремяРезультат;
	// 0,0000115740740740741 = 1 сек.
	// 1                     = 24 часа 00 мин 00 сек.
	Если ТипЗнч(Число) = Тип("Строка") Тогда
		// MS Office, LibreOffice.
		Если Прав(Число, 5) = "E-005" ИЛИ Прав(Число, 3) = "E-5" Тогда
			Делитель = 100000;
		ИначеЕсли Прав(Число, 3) = "E-4" Тогда
			Делитель = 10000;
		ИначеЕсли Прав(Число, 3) = "E-3" Тогда
			Делитель = 1000;
		КонецЕсли;
		КВоСекунд = Цел(Число(Лев(Число,15)) / Делитель / 0.0000115740740740741) + 1;
	Иначе
		// LibreOffice.
		КВоСекунд1= Число * 100000 / 1.15740740740741;
		КВоСекунд = Цел(КВоСекунд1);
		КВоСекунд = ?(КВоСекунд1 > 10, КВоСекунд + 1, КВоСекунд);
	КонецЕсли;
	ВремяРезультат = Дата("19000101000000") + КВоСекунд;
	Возврат ВремяРезультат;
КонецФункции

Функция ПолучитьОбъектФайл(Знач ФайлEXCEL, РаспаковатьXLSX = Ложь, ZIPКаталог) Экспорт
	
	Если НЕ ЗначениеЗаполнено(ФайлEXCEL) Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Файл = Новый Файл(ФайлEXCEL);
	Если НЕ Файл.Существует() Тогда
		Сообщить("Файл не существует:
		|" + ФайлEXCEL);
		Возврат Неопределено;
	КонецЕсли;
	
	// Проверка: Занят ли файл другим процессом?
	//todo  вываливается непонятная ошибка на строке objFSO.MoveFile
	//Попытка
	//	objFSO = Новый COMОбъект("Scripting.FileSystemObject");
	//	objFSO.MoveFile(ФайлEXCEL, ФайлEXCEL);
	//	objFile = objFSO.GetFile(ФайлEXCEL);
	//Исключение
	//	Сообщить("Ошибка открытия файла/Файл занят другой программой:
	//	|" + ФайлEXCEL +" : " +ОписаниеОшибки());
	//	Возврат Неопределено;
	//КонецПопытки;
	
	
	Если (ВРег(Файл.Расширение) = ".XLSX" ИЛИ ВРег(Файл.Расширение) = ".XLSM") И РаспаковатьXLSX Тогда
		// Распаковка файла XLSX во временный каталог.
		XLSXРаспакован = РаспаковатьXLSXвКаталогВременныхФайлов(ФайлEXCEL, ZIPКаталог);
		Если НЕ XLSXРаспакован Тогда
			Сообщить("Ошибка распаковки файла/Файл имеет другой формат (не xlsx и не xlsm):
			|" + ФайлEXCEL);
			Возврат Неопределено;
		КонецЕсли;
	КонецЕсли;
	
	Возврат Файл;
	
КонецФункции

Функция РаспаковатьXLSXвКаталогВременныхФайлов(ФайлEXCEL, ZIPКаталог)
	
	Попытка
		
		УдалитьФайлы(ZIPКаталог);
		
		ZIPФайл = Новый ЧтениеZipФайла;
		ZIPФайл.Открыть(ФайлEXCEL);
		ZIPФайл.ИзвлечьВсе(ZIPКаталог, РежимВосстановленияПутейФайловZIP.Восстанавливать);
		
		Возврат Истина;
		
	Исключение
		Сообщить("Ошибка работы с Excel: "+ ОписаниеОшибки());
		Возврат Ложь;
	КонецПопытки;
	
КонецФункции

Функция СформироватьZIPКаталог(ФайлEXCEL) Экспорт
	
	УникальныйИдентификатор = Новый УникальныйИдентификатор;		
	ZIPКаталог = КаталогВременныхФайлов() + УникальныйИдентификатор + "\XLSX\";
	мТекущийZipКаталог =  ZIPКаталог;	
	// проверка наличия файла, его занятости другим приложением и распаковка в каталог ZIPКаталог
	
	Файл = ПолучитьОбъектФайл(ФайлEXCEL, Истина, ZIPКаталог);
	Если Файл = Неопределено Тогда
		ЭД_ОбщегоНазначения.СообщитьОбОшибке("Невозможно загрузить данные с листа, т.к. невозможно открыть для чтения файл:
		|" + ФайлEXCEL);
		УдалитьZIPКаталог(); 
		Возврат ложь;
	КонецЕсли;
	Если НЕ ВРег(Файл.Расширение) = ".XLSX" И НЕ ВРег(Файл.Расширение) = ".XLSM" Тогда
		УдалитьZIPКаталог(); 
		Возврат ложь ;
	КонецЕсли;
	
	ЗаполнитьТаблицуЛистов(ZIPКаталог);	
	
	
	КэшПеременныхЗаполнен = Ложь; 

	Возврат Истина;
КонецФункции

Процедура УдалитьZIPКаталог() Экспорт
				
	Если ЗначениеЗаполнено(мТекущийZipКаталог) Тогда
	   КаталогКУдалению  =  Сред(мТекущийZipКаталог,1,СтрДлина(мТекущийZipКаталог)-6); // удаляем  \XLSX\"
		Попытка
			УдалитьФайлы(КаталогКУдалению);
		Исключение
			ЭД_ОбщегоНазначения.СообщитьОбОшибке("Не удалось удалить временный каталог :"+ КаталогКУдалению +" по причине: "+ ОписаниеОшибки());
		КонецПопытки; 	
	КонецЕсли;
	мТекущийZipКаталог = "";		
КонецПроцедуры

Функция ПолучитьСписокЛистов() Экспорт
	СписокЛистов = новый СписокЗначений;
	Если Тип(ТаблицаЛистов) = Тип("ТаблицаЗначений")Тогда
		Для каждого стр Из ТаблицаЛистов Цикл
			НС = СписокЛистов.Добавить();
			НС.Значение = Число(стр.rid);
			НС.Представление = стр.name;	
		КонецЦикла;
	КонецЕсли;	
	Возврат СписокЛистов;	
КонецФункции

Функция ПолучитьТаблицуЛистов() Экспорт
	Возврат ТаблицаЛистов;	
КонецФункции

Процедура ЗаполнитьТаблицуЛистов(ZIPКаталог)	
	ТаблицаЛистов = Новый ТаблицаЗначений;
	ТаблицаЛистов.Колонки.Добавить("rid");
	ТаблицаЛистов.Колонки.Добавить("sheetId");
	ТаблицаЛистов.Колонки.Добавить("name");
	
	ТаблицаИменованныхОбластей = Новый ТаблицаЗначений;
	ТаблицаИменованныхОбластей.Колонки.Добавить("name");
	ТаблицаИменованныхОбластей.Колонки.Добавить("localSheetId");
	ТаблицаИменованныхОбластей.Колонки.Добавить("address");
	
	SheetX = Новый ЧтениеXML;
	SheetX.ОткрытьФайл(ZIPКаталог + "xl\workbook.xml");
	
	Пока SheetX.Прочитать() Цикл
		Если ВРег(SheetX.Имя) = "SHEET" И SheetX.ТипУзла = ТипУзлаXML.НачалоЭлемента Тогда
			Попытка
				НС = ТаблицаЛистов.Добавить();
				НС.rid = СтрЗаменить(SheetX.ЗначениеАтрибута("r:id"), "rId", "");
				НС.sheetId = SheetX.ЗначениеАтрибута("sheetId");
				НС.name = SheetX.ЗначениеАтрибута("name");
			Исключение
			КонецПопытки;
		КонецЕсли;
		Если ВРег(SheetX.Имя) = "DEFINEDNAME" И SheetX.ТипУзла = ТипУзлаXML.НачалоЭлемента Тогда
			Попытка
				
				НС = ТаблицаИменованныхОбластей.Добавить();
				НС.name = SheetX.ЗначениеАтрибута("name");
				НС.localSheetId = SheetX.ЗначениеАтрибута("localSheetId");
				
				SheetX.Прочитать();
				Если ВРег(SheetX.Имя) = "#TEXT" Тогда
					НС.address = SheetX.Значение;
				КонецЕсли;
				
			Исключение
			КонецПопытки;
		КонецЕсли;
	КонецЦикла;	

КонецПроцедуры

// Удаляет из строки указанное количество символов справа.
//
// Параметры:
//  Текст         - Строка - строка, в которой необходимо удалить последние символы;
//  ЧислоСимволов - Число  - количество удаляемых символов.
//
Процедура УдалитьПоследнийСимволВСтроке(Текст, ЧислоСимволов)
	Текст = Лев(Текст, СтрДлина(Текст) - ЧислоСимволов);
КонецПроцедуры

// Преобразование координат ячейки Excel формата A1 в формат RC
Функция ВернутьКоординатыКолонки(ИмяКолонки)
	
	ДлинаИмени = СтрДлина(ИмяКолонки);
	Колонка    = "";
	Строка     = "";
	
	ПишемСтроку = Ложь;
	Для Инд = 1 По ДлинаИмени Цикл
		
		ТекСимвол = Сред(ИмяКолонки, Инд, 1);
		Если СимволЧисло(ТекСимвол) Тогда
			ПишемСтроку = Истина;
		КонецЕсли;
		
		Если ПишемСтроку Тогда
			Строка = Строка + ТекСимвол;
		Иначе
			Колонка = Колонка + ТекСимвол;
		КонецЕсли;
		
	КонецЦикла;
	
	Возврат Новый Структура("Строка, Колонка", Число(Строка), РассчитатьКоординатуКолонки(Колонка));
	
КонецФункции

Функция РассчитатьКоординатуКолонки(ИмяКолонки)
	
	КодСимволаНачала = КодСимвола("A");
	Если СтрДлина(ИмяКолонки) = 2 Тогда
		Координата = (КодСимвола(ИмяКолонки, 1) - КодСимволаНачала + 1)*26 + (КодСимвола(ИмяКолонки, 2) - КодСимволаНачала + 1);
		//Координата = (КодСимвола(ИмяКолонки, 2) - КодСимволаНачала + 1)*28 + (КодСимвола(ИмяКолонки, 2) - КодСимволаНачала);
	Иначе
		Координата = КодСимвола(ИмяКолонки, 1) - КодСимволаНачала + 1;
	КонецЕсли;
	
	Возврат Координата;
	
КонецФункции

Функция СимволЧисло(Символ)
	Возврат СтрЧислоВхождений("1234567890", ВРег(Символ)) >0;
КонецФункции

///////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ - ОБРАБОТЧИКИ СОБЫТИЙ

////////////////////////////////////////////////////////////////////////////////
// ОПЕРАТОРЫ ОСНОВНОЙ ПРОГРАММЫ
ТаблицаЛистов = Неопределено;
ТаблицаИменованныхОбластей = Неопределено;
мТекущийZipКаталог = "";
КэшПеременныхЗаполнен = Ложь;